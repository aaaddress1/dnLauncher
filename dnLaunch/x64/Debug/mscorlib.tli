// Created by Microsoft (R) C/C++ Compiler Version 14.27.29112.0 (c12d65cc).
//
// C:\Users\aaaddress1\Desktop\dnLaunch\dnLaunch\x64\Debug\mscorlib.tli
//
// Wrapper implementations for Win32 type library mscorlib.tlb
// compiler-generated file created 06/23/21 at 21:42:26 - DO NOT EDIT!

#pragma once

//
// interface IComparable wrapper method implementations
//

inline long IComparable::CompareTo ( const _variant_t & obj ) {
    long _result = 0;
    HRESULT _hr = raw_CompareTo(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ICloneable wrapper method implementations
//

inline _variant_t ICloneable::Clone ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Clone(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IEnumerable wrapper method implementations
//

inline IEnumVARIANTPtr IEnumerable::GetEnumerator ( ) {
    struct IEnumVARIANT * _result = 0;
    HRESULT _hr = raw_GetEnumerator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IEnumVARIANTPtr(_result, false);
}

//
// interface IList wrapper method implementations
//

inline _variant_t IList::GetItem ( long index ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void IList::PutRefItem ( long index, const _variant_t & pRetVal ) {
    HRESULT _hr = putref_Item(index, pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IList::Add ( const _variant_t & value ) {
    long _result = 0;
    HRESULT _hr = raw_Add(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL IList::Contains ( const _variant_t & value ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IList::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline VARIANT_BOOL IList::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL IList::GetIsFixedSize ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFixedSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long IList::IndexOf ( const _variant_t & value ) {
    long _result = 0;
    HRESULT _hr = raw_IndexOf(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IList::Insert ( long index, const _variant_t & value ) {
    HRESULT _hr = raw_Insert(index, value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IList::Remove ( const _variant_t & value ) {
    HRESULT _hr = raw_Remove(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IList::RemoveAt ( long index ) {
    HRESULT _hr = raw_RemoveAt(index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IEnumerator wrapper method implementations
//

inline VARIANT_BOOL IEnumerator::MoveNext ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_MoveNext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t IEnumerator::GetCurrent ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Current(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline HRESULT IEnumerator::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IDisposable wrapper method implementations
//

inline HRESULT IDisposable::Dispose ( ) {
    HRESULT _hr = raw_Dispose();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IComparer wrapper method implementations
//

inline long IComparer::Compare ( const _variant_t & x, const _variant_t & y ) {
    long _result = 0;
    HRESULT _hr = raw_Compare(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IEqualityComparer wrapper method implementations
//

inline VARIANT_BOOL IEqualityComparer::Equals ( const _variant_t & x, const _variant_t & y ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long IEqualityComparer::GetHashCode ( const _variant_t & obj ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IDeserializationCallback wrapper method implementations
//

inline HRESULT IDeserializationCallback::OnDeserialization ( const _variant_t & sender ) {
    HRESULT _hr = raw_OnDeserialization(sender);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _Activator wrapper method implementations
//

inline HRESULT _Activator::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Activator::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Activator::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Activator::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAppDomainSetup wrapper method implementations
//

inline _bstr_t IAppDomainSetup::GetApplicationBase ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ApplicationBase(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IAppDomainSetup::PutApplicationBase ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ApplicationBase(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IAppDomainSetup::GetApplicationName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ApplicationName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IAppDomainSetup::PutApplicationName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ApplicationName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IAppDomainSetup::GetCachePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CachePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IAppDomainSetup::PutCachePath ( _bstr_t pRetVal ) {
    HRESULT _hr = put_CachePath(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IAppDomainSetup::GetConfigurationFile ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ConfigurationFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IAppDomainSetup::PutConfigurationFile ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ConfigurationFile(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IAppDomainSetup::GetDynamicBase ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DynamicBase(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IAppDomainSetup::PutDynamicBase ( _bstr_t pRetVal ) {
    HRESULT _hr = put_DynamicBase(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IAppDomainSetup::GetLicenseFile ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LicenseFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IAppDomainSetup::PutLicenseFile ( _bstr_t pRetVal ) {
    HRESULT _hr = put_LicenseFile(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IAppDomainSetup::GetPrivateBinPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PrivateBinPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IAppDomainSetup::PutPrivateBinPath ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PrivateBinPath(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IAppDomainSetup::GetPrivateBinPathProbe ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PrivateBinPathProbe(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IAppDomainSetup::PutPrivateBinPathProbe ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PrivateBinPathProbe(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IAppDomainSetup::GetShadowCopyDirectories ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ShadowCopyDirectories(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IAppDomainSetup::PutShadowCopyDirectories ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ShadowCopyDirectories(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IAppDomainSetup::GetShadowCopyFiles ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ShadowCopyFiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IAppDomainSetup::PutShadowCopyFiles ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ShadowCopyFiles(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _Attribute wrapper method implementations
//

inline HRESULT _Attribute::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Attribute::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Attribute::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Attribute::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _Thread wrapper method implementations
//

inline HRESULT _Thread::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Thread::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Thread::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Thread::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IObjectHandle wrapper method implementations
//

inline _variant_t IObjectHandle::Unwrap ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Unwrap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IHashCodeProvider wrapper method implementations
//

inline long IHashCodeProvider::GetHashCode ( const _variant_t & obj ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IDictionaryEnumerator wrapper method implementations
//

inline _variant_t IDictionaryEnumerator::Getkey ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_key(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t IDictionaryEnumerator::Getvalue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline struct DictionaryEntry IDictionaryEnumerator::GetEntry ( ) {
    struct DictionaryEntry _result;
    HRESULT _hr = get_Entry(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISymbolDocument wrapper method implementations
//

inline _bstr_t ISymbolDocument::GetUrl ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Url(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline GUID ISymbolDocument::GetDocumentType ( ) {
    GUID _result;
    HRESULT _hr = get_DocumentType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline GUID ISymbolDocument::GetLanguage ( ) {
    GUID _result;
    HRESULT _hr = get_Language(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline GUID ISymbolDocument::GetLanguageVendor ( ) {
    GUID _result;
    HRESULT _hr = get_LanguageVendor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline GUID ISymbolDocument::GetCheckSumAlgorithmId ( ) {
    GUID _result;
    HRESULT _hr = get_CheckSumAlgorithmId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * ISymbolDocument::GetCheckSum ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCheckSum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ISymbolDocument::FindClosestLine ( long line ) {
    long _result = 0;
    HRESULT _hr = raw_FindClosestLine(line, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL ISymbolDocument::GetHasEmbeddedSource ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasEmbeddedSource(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ISymbolDocument::GetSourceLength ( ) {
    long _result = 0;
    HRESULT _hr = get_SourceLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * ISymbolDocument::GetSourceRange ( long startLine, long startColumn, long endLine, long endColumn ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetSourceRange(startLine, startColumn, endLine, endColumn, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISymbolDocumentWriter wrapper method implementations
//

inline HRESULT ISymbolDocumentWriter::SetSource ( SAFEARRAY * Source ) {
    HRESULT _hr = raw_SetSource(Source);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolDocumentWriter::SetCheckSum ( GUID algorithmId, SAFEARRAY * checkSum ) {
    HRESULT _hr = raw_SetCheckSum(algorithmId, checkSum);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ISymbolNamespace wrapper method implementations
//

inline _bstr_t ISymbolNamespace::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline SAFEARRAY * ISymbolNamespace::GetNamespaces ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetNamespaces(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * ISymbolNamespace::GetVariables ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetVariables(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISymbolVariable wrapper method implementations
//

inline _bstr_t ISymbolVariable::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _variant_t ISymbolVariable::GetAttributes ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline SAFEARRAY * ISymbolVariable::GetSignature ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetSignature(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum SymAddressKind ISymbolVariable::GetAddressKind ( ) {
    enum SymAddressKind _result;
    HRESULT _hr = get_AddressKind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ISymbolVariable::GetAddressField1 ( ) {
    long _result = 0;
    HRESULT _hr = get_AddressField1(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ISymbolVariable::GetAddressField2 ( ) {
    long _result = 0;
    HRESULT _hr = get_AddressField2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ISymbolVariable::GetAddressField3 ( ) {
    long _result = 0;
    HRESULT _hr = get_AddressField3(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ISymbolVariable::GetStartOffset ( ) {
    long _result = 0;
    HRESULT _hr = get_StartOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ISymbolVariable::GetEndOffset ( ) {
    long _result = 0;
    HRESULT _hr = get_EndOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _AssemblyName wrapper method implementations
//

inline HRESULT _AssemblyName::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AssemblyName::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AssemblyName::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AssemblyName::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _ParameterInfo wrapper method implementations
//

inline HRESULT _ParameterInfo::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ParameterInfo::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ParameterInfo::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ParameterInfo::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _Module wrapper method implementations
//

inline HRESULT _Module::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Module::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Module::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Module::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ISymbolWriter wrapper method implementations
//

inline HRESULT ISymbolWriter::Initialize ( long emitter, _bstr_t filename, VARIANT_BOOL fFullBuild ) {
    HRESULT _hr = raw_Initialize(emitter, filename, fFullBuild);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline ISymbolDocumentWriterPtr ISymbolWriter::DefineDocument ( _bstr_t Url, GUID Language, GUID LanguageVendor, GUID DocumentType ) {
    struct ISymbolDocumentWriter * _result = 0;
    HRESULT _hr = raw_DefineDocument(Url, Language, LanguageVendor, DocumentType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolDocumentWriterPtr(_result, false);
}

inline HRESULT ISymbolWriter::SetUserEntryPoint ( struct SymbolToken entryMethod ) {
    HRESULT _hr = raw_SetUserEntryPoint(entryMethod);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolWriter::OpenMethod ( struct SymbolToken Method ) {
    HRESULT _hr = raw_OpenMethod(Method);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolWriter::CloseMethod ( ) {
    HRESULT _hr = raw_CloseMethod();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolWriter::DefineSequencePoints ( struct ISymbolDocumentWriter * document, SAFEARRAY * offsets, SAFEARRAY * lines, SAFEARRAY * columns, SAFEARRAY * endLines, SAFEARRAY * endColumns ) {
    HRESULT _hr = raw_DefineSequencePoints(document, offsets, lines, columns, endLines, endColumns);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline long ISymbolWriter::OpenScope ( long StartOffset ) {
    long _result = 0;
    HRESULT _hr = raw_OpenScope(StartOffset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT ISymbolWriter::CloseScope ( long EndOffset ) {
    HRESULT _hr = raw_CloseScope(EndOffset);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolWriter::SetScopeRange ( long scopeID, long StartOffset, long EndOffset ) {
    HRESULT _hr = raw_SetScopeRange(scopeID, StartOffset, EndOffset);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolWriter::DefineLocalVariable ( _bstr_t name, enum FieldAttributes Attributes, SAFEARRAY * signature, enum SymAddressKind addrKind, long addr1, long addr2, long addr3, long StartOffset, long EndOffset ) {
    HRESULT _hr = raw_DefineLocalVariable(name, Attributes, signature, addrKind, addr1, addr2, addr3, StartOffset, EndOffset);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolWriter::DefineParameter ( _bstr_t name, enum ParameterAttributes Attributes, long sequence, enum SymAddressKind addrKind, long addr1, long addr2, long addr3 ) {
    HRESULT _hr = raw_DefineParameter(name, Attributes, sequence, addrKind, addr1, addr2, addr3);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolWriter::DefineField ( struct SymbolToken parent, _bstr_t name, enum FieldAttributes Attributes, SAFEARRAY * signature, enum SymAddressKind addrKind, long addr1, long addr2, long addr3 ) {
    HRESULT _hr = raw_DefineField(parent, name, Attributes, signature, addrKind, addr1, addr2, addr3);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolWriter::DefineGlobalVariable ( _bstr_t name, enum FieldAttributes Attributes, SAFEARRAY * signature, enum SymAddressKind addrKind, long addr1, long addr2, long addr3 ) {
    HRESULT _hr = raw_DefineGlobalVariable(name, Attributes, signature, addrKind, addr1, addr2, addr3);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolWriter::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolWriter::SetSymAttribute ( struct SymbolToken parent, _bstr_t name, SAFEARRAY * data ) {
    HRESULT _hr = raw_SetSymAttribute(parent, name, data);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolWriter::OpenNamespace ( _bstr_t name ) {
    HRESULT _hr = raw_OpenNamespace(name);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolWriter::CloseNamespace ( ) {
    HRESULT _hr = raw_CloseNamespace();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolWriter::UsingNamespace ( _bstr_t FullName ) {
    HRESULT _hr = raw_UsingNamespace(FullName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolWriter::SetMethodSourceRange ( struct ISymbolDocumentWriter * startDoc, long startLine, long startColumn, struct ISymbolDocumentWriter * endDoc, long endLine, long endColumn ) {
    HRESULT _hr = raw_SetMethodSourceRange(startDoc, startLine, startColumn, endDoc, endLine, endColumn);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISymbolWriter::SetUnderlyingWriter ( long underlyingWriter ) {
    HRESULT _hr = raw_SetUnderlyingWriter(underlyingWriter);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IObjectReference wrapper method implementations
//

inline _variant_t IObjectReference::GetRealObject ( struct StreamingContext Context ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetRealObject(Context, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IResourceReader wrapper method implementations
//

inline HRESULT IResourceReader::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline IDictionaryEnumeratorPtr IResourceReader::GetEnumerator ( ) {
    struct IDictionaryEnumerator * _result = 0;
    HRESULT _hr = raw_GetEnumerator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDictionaryEnumeratorPtr(_result, false);
}

//
// interface IResourceWriter wrapper method implementations
//

inline HRESULT IResourceWriter::AddResource ( _bstr_t name, _bstr_t value ) {
    HRESULT _hr = raw_AddResource(name, value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IResourceWriter::AddResource_2 ( _bstr_t name, const _variant_t & value ) {
    HRESULT _hr = raw_AddResource_2(name, value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IResourceWriter::AddResource_3 ( _bstr_t name, SAFEARRAY * value ) {
    HRESULT _hr = raw_AddResource_3(name, value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IResourceWriter::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IResourceWriter::Generate ( ) {
    HRESULT _hr = raw_Generate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IIdentity wrapper method implementations
//

inline _bstr_t IIdentity::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IIdentity::GetAuthenticationType ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_AuthenticationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL IIdentity::GetIsAuthenticated ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsAuthenticated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IPrincipal wrapper method implementations
//

inline IIdentityPtr IPrincipal::GetIdentity ( ) {
    struct IIdentity * _result = 0;
    HRESULT _hr = get_Identity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IIdentityPtr(_result, false);
}

inline VARIANT_BOOL IPrincipal::IsInRole ( _bstr_t role ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsInRole(role, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ICustomMarshaler wrapper method implementations
//

inline _variant_t ICustomMarshaler::MarshalNativeToManaged ( long pNativeData ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_MarshalNativeToManaged(pNativeData, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline long ICustomMarshaler::MarshalManagedToNative ( const _variant_t & ManagedObj ) {
    long _result = 0;
    HRESULT _hr = raw_MarshalManagedToNative(ManagedObj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT ICustomMarshaler::CleanUpNativeData ( long pNativeData ) {
    HRESULT _hr = raw_CleanUpNativeData(pNativeData);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ICustomMarshaler::CleanUpManagedData ( const _variant_t & ManagedObj ) {
    HRESULT _hr = raw_CleanUpManagedData(ManagedObj);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline long ICustomMarshaler::GetNativeDataSize ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetNativeDataSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ICustomAdapter wrapper method implementations
//

inline IUnknownPtr ICustomAdapter::GetUnderlyingObject ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = raw_GetUnderlyingObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface ITypeLibExporterNameProvider wrapper method implementations
//

inline SAFEARRAY * ITypeLibExporterNameProvider::GetNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IPermission wrapper method implementations
//

inline IPermissionPtr IPermission::Copy ( ) {
    struct IPermission * _result = 0;
    HRESULT _hr = raw_Copy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPermissionPtr(_result, false);
}

inline IPermissionPtr IPermission::Intersect ( struct IPermission * Target ) {
    struct IPermission * _result = 0;
    HRESULT _hr = raw_Intersect(Target, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPermissionPtr(_result, false);
}

inline IPermissionPtr IPermission::Union ( struct IPermission * Target ) {
    struct IPermission * _result = 0;
    HRESULT _hr = raw_Union(Target, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPermissionPtr(_result, false);
}

inline VARIANT_BOOL IPermission::IsSubsetOf ( struct IPermission * Target ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsSubsetOf(Target, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IPermission::Demand ( ) {
    HRESULT _hr = raw_Demand();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IStackWalk wrapper method implementations
//

inline HRESULT IStackWalk::Assert ( ) {
    HRESULT _hr = raw_Assert();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IStackWalk::Demand ( ) {
    HRESULT _hr = raw_Demand();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IStackWalk::Deny ( ) {
    HRESULT _hr = raw_Deny();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IStackWalk::PermitOnly ( ) {
    HRESULT _hr = raw_PermitOnly();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IUnrestrictedPermission wrapper method implementations
//

inline VARIANT_BOOL IUnrestrictedPermission::IsUnrestricted ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsUnrestricted(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IChannel wrapper method implementations
//

inline long IChannel::GetChannelPriority ( ) {
    long _result = 0;
    HRESULT _hr = get_ChannelPriority(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IChannel::GetChannelName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ChannelName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IChannel::Parse ( _bstr_t Url, BSTR * objectURI ) {
    BSTR _result = 0;
    HRESULT _hr = raw_Parse(Url, objectURI, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IChannelReceiver wrapper method implementations
//

inline _variant_t IChannelReceiver::GetChannelData ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_ChannelData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline SAFEARRAY * IChannelReceiver::GetUrlsForUri ( _bstr_t objectURI ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetUrlsForUri(objectURI, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IChannelReceiver::StartListening ( const _variant_t & data ) {
    HRESULT _hr = raw_StartListening(data);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IChannelReceiver::StopListening ( const _variant_t & data ) {
    HRESULT _hr = raw_StopListening(data);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IMethodCallMessage wrapper method implementations
//

inline long IMethodCallMessage::GetInArgCount ( ) {
    long _result = 0;
    HRESULT _hr = get_InArgCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IMethodCallMessage::GetInArgName ( long index ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetInArgName(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _variant_t IMethodCallMessage::GetInArg ( long argNum ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetInArg(argNum, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline SAFEARRAY * IMethodCallMessage::GetInArgs ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_InArgs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IChannelDataStore wrapper method implementations
//

inline SAFEARRAY * IChannelDataStore::GetChannelUris ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ChannelUris(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t IChannelDataStore::GetItem ( const _variant_t & key ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Item(key, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void IChannelDataStore::PutRefItem ( const _variant_t & key, const _variant_t & pRetVal ) {
    HRESULT _hr = putref_Item(key, pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITransportHeaders wrapper method implementations
//

inline _variant_t ITransportHeaders::GetItem ( const _variant_t & key ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Item(key, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void ITransportHeaders::PutRefItem ( const _variant_t & key, const _variant_t & pRetVal ) {
    HRESULT _hr = putref_Item(key, pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline IEnumVARIANTPtr ITransportHeaders::GetEnumerator ( ) {
    struct IEnumVARIANT * _result = 0;
    HRESULT _hr = raw_GetEnumerator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IEnumVARIANTPtr(_result, false);
}

//
// interface IDynamicProperty wrapper method implementations
//

inline _bstr_t IDynamicProperty::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IMessageCtrl wrapper method implementations
//

inline HRESULT IMessageCtrl::Cancel ( long msToCancel ) {
    HRESULT _hr = raw_Cancel(msToCancel);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IFieldInfo wrapper method implementations
//

inline SAFEARRAY * IFieldInfo::GetFieldNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_FieldNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IFieldInfo::PutFieldNames ( SAFEARRAY * pRetVal ) {
    HRESULT _hr = put_FieldNames(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline SAFEARRAY * IFieldInfo::GetFieldTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_FieldTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IFieldInfo::PutFieldTypes ( SAFEARRAY * pRetVal ) {
    HRESULT _hr = put_FieldTypes(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IChannelInfo wrapper method implementations
//

inline SAFEARRAY * IChannelInfo::GetChannelData ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ChannelData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IChannelInfo::PutChannelData ( SAFEARRAY * pRetVal ) {
    HRESULT _hr = put_ChannelData(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ISoapXsd wrapper method implementations
//

inline _bstr_t ISoapXsd::GetXsdType ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetXsdType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface INormalizeForIsolatedStorage wrapper method implementations
//

inline _variant_t INormalizeForIsolatedStorage::Normalize ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Normalize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface ISoapMessage wrapper method implementations
//

inline SAFEARRAY * ISoapMessage::GetParamNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ParamNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ISoapMessage::PutParamNames ( SAFEARRAY * pRetVal ) {
    HRESULT _hr = put_ParamNames(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline SAFEARRAY * ISoapMessage::GetParamValues ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ParamValues(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ISoapMessage::PutParamValues ( SAFEARRAY * pRetVal ) {
    HRESULT _hr = put_ParamValues(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline SAFEARRAY * ISoapMessage::GetParamTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ParamTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ISoapMessage::PutParamTypes ( SAFEARRAY * pRetVal ) {
    HRESULT _hr = put_ParamTypes(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t ISoapMessage::GetMethodName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_MethodName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void ISoapMessage::PutMethodName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_MethodName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t ISoapMessage::GetXmlNameSpace ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_XmlNameSpace(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void ISoapMessage::PutXmlNameSpace ( _bstr_t pRetVal ) {
    HRESULT _hr = put_XmlNameSpace(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline SAFEARRAY * ISoapMessage::Getheaders ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_headers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ISoapMessage::Putheaders ( SAFEARRAY * pRetVal ) {
    HRESULT _hr = put_headers(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _AssemblyBuilder wrapper method implementations
//

inline HRESULT _AssemblyBuilder::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AssemblyBuilder::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AssemblyBuilder::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AssemblyBuilder::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _ConstructorBuilder wrapper method implementations
//

inline HRESULT _ConstructorBuilder::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ConstructorBuilder::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ConstructorBuilder::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ConstructorBuilder::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _CustomAttributeBuilder wrapper method implementations
//

inline HRESULT _CustomAttributeBuilder::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _CustomAttributeBuilder::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _CustomAttributeBuilder::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _CustomAttributeBuilder::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _EnumBuilder wrapper method implementations
//

inline HRESULT _EnumBuilder::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _EnumBuilder::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _EnumBuilder::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _EnumBuilder::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _EventBuilder wrapper method implementations
//

inline HRESULT _EventBuilder::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _EventBuilder::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _EventBuilder::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _EventBuilder::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _FieldBuilder wrapper method implementations
//

inline HRESULT _FieldBuilder::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _FieldBuilder::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _FieldBuilder::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _FieldBuilder::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _ILGenerator wrapper method implementations
//

inline HRESULT _ILGenerator::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ILGenerator::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ILGenerator::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ILGenerator::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _LocalBuilder wrapper method implementations
//

inline HRESULT _LocalBuilder::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _LocalBuilder::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _LocalBuilder::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _LocalBuilder::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _MethodBuilder wrapper method implementations
//

inline HRESULT _MethodBuilder::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _MethodBuilder::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _MethodBuilder::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _MethodBuilder::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _MethodRental wrapper method implementations
//

inline HRESULT _MethodRental::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _MethodRental::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _MethodRental::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _MethodRental::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _ModuleBuilder wrapper method implementations
//

inline HRESULT _ModuleBuilder::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ModuleBuilder::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ModuleBuilder::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ModuleBuilder::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _ParameterBuilder wrapper method implementations
//

inline HRESULT _ParameterBuilder::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ParameterBuilder::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ParameterBuilder::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ParameterBuilder::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _PropertyBuilder wrapper method implementations
//

inline HRESULT _PropertyBuilder::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _PropertyBuilder::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _PropertyBuilder::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _PropertyBuilder::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _SignatureHelper wrapper method implementations
//

inline HRESULT _SignatureHelper::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _SignatureHelper::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _SignatureHelper::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _SignatureHelper::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _TypeBuilder wrapper method implementations
//

inline HRESULT _TypeBuilder::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _TypeBuilder::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _TypeBuilder::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _TypeBuilder::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ICryptoTransform wrapper method implementations
//

inline long ICryptoTransform::GetInputBlockSize ( ) {
    long _result = 0;
    HRESULT _hr = get_InputBlockSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ICryptoTransform::GetOutputBlockSize ( ) {
    long _result = 0;
    HRESULT _hr = get_OutputBlockSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL ICryptoTransform::GetCanTransformMultipleBlocks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanTransformMultipleBlocks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL ICryptoTransform::GetCanReuseTransform ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanReuseTransform(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ICryptoTransform::TransformBlock ( SAFEARRAY * inputBuffer, long inputOffset, long inputCount, SAFEARRAY * outputBuffer, long outputOffset ) {
    long _result = 0;
    HRESULT _hr = raw_TransformBlock(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * ICryptoTransform::TransformFinalBlock ( SAFEARRAY * inputBuffer, long inputOffset, long inputCount ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_TransformFinalBlock(inputBuffer, inputOffset, inputCount, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ICollection wrapper method implementations
//

inline HRESULT ICollection::CopyTo ( struct _Array * Array, long index ) {
    HRESULT _hr = raw_CopyTo(Array, index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline long ICollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t ICollection::GetSyncRoot ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_SyncRoot(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline VARIANT_BOOL ICollection::GetIsSynchronized ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSynchronized(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IDictionary wrapper method implementations
//

inline _variant_t IDictionary::GetItem ( const _variant_t & key ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Item(key, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void IDictionary::PutRefItem ( const _variant_t & key, const _variant_t & pRetVal ) {
    HRESULT _hr = putref_Item(key, pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline ICollectionPtr IDictionary::GetKeys ( ) {
    struct ICollection * _result = 0;
    HRESULT _hr = get_Keys(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICollectionPtr(_result, false);
}

inline ICollectionPtr IDictionary::GetValues ( ) {
    struct ICollection * _result = 0;
    HRESULT _hr = get_Values(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICollectionPtr(_result, false);
}

inline VARIANT_BOOL IDictionary::Contains ( const _variant_t & key ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(key, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IDictionary::Add ( const _variant_t & key, const _variant_t & value ) {
    HRESULT _hr = raw_Add(key, value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IDictionary::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline VARIANT_BOOL IDictionary::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL IDictionary::GetIsFixedSize ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFixedSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline IDictionaryEnumeratorPtr IDictionary::GetEnumerator ( ) {
    struct IDictionaryEnumerator * _result = 0;
    HRESULT _hr = raw_GetEnumerator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDictionaryEnumeratorPtr(_result, false);
}

inline HRESULT IDictionary::Remove ( const _variant_t & key ) {
    HRESULT _hr = raw_Remove(key);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IChannelSinkBase wrapper method implementations
//

inline IDictionaryPtr IChannelSinkBase::GetProperties ( ) {
    struct IDictionary * _result = 0;
    HRESULT _hr = get_Properties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDictionaryPtr(_result, false);
}

//
// interface IMessage wrapper method implementations
//

inline IDictionaryPtr IMessage::GetProperties ( ) {
    struct IDictionary * _result = 0;
    HRESULT _hr = get_Properties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDictionaryPtr(_result, false);
}

//
// interface IMessageSink wrapper method implementations
//

inline IMessagePtr IMessageSink::SyncProcessMessage ( struct IMessage * msg ) {
    struct IMessage * _result = 0;
    HRESULT _hr = raw_SyncProcessMessage(msg, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessagePtr(_result, false);
}

inline IMessageCtrlPtr IMessageSink::AsyncProcessMessage ( struct IMessage * msg, struct IMessageSink * replySink ) {
    struct IMessageCtrl * _result = 0;
    HRESULT _hr = raw_AsyncProcessMessage(msg, replySink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageCtrlPtr(_result, false);
}

inline IMessageSinkPtr IMessageSink::GetNextSink ( ) {
    struct IMessageSink * _result = 0;
    HRESULT _hr = get_NextSink(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageSinkPtr(_result, false);
}

//
// interface IChannelSender wrapper method implementations
//

inline IMessageSinkPtr IChannelSender::CreateMessageSink ( _bstr_t Url, const _variant_t & remoteChannelData, BSTR * objectURI ) {
    struct IMessageSink * _result = 0;
    HRESULT _hr = raw_CreateMessageSink(Url, remoteChannelData, objectURI, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageSinkPtr(_result, false);
}

//
// interface IContributeClientContextSink wrapper method implementations
//

inline IMessageSinkPtr IContributeClientContextSink::GetClientContextSink ( struct IMessageSink * NextSink ) {
    struct IMessageSink * _result = 0;
    HRESULT _hr = raw_GetClientContextSink(NextSink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageSinkPtr(_result, false);
}

//
// interface IContributeServerContextSink wrapper method implementations
//

inline IMessageSinkPtr IContributeServerContextSink::GetServerContextSink ( struct IMessageSink * NextSink ) {
    struct IMessageSink * _result = 0;
    HRESULT _hr = raw_GetServerContextSink(NextSink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageSinkPtr(_result, false);
}

//
// interface IDynamicMessageSink wrapper method implementations
//

inline HRESULT IDynamicMessageSink::ProcessMessageStart ( struct IMessage * reqMsg, VARIANT_BOOL bCliSide, VARIANT_BOOL bAsync ) {
    HRESULT _hr = raw_ProcessMessageStart(reqMsg, bCliSide, bAsync);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IDynamicMessageSink::ProcessMessageFinish ( struct IMessage * replyMsg, VARIANT_BOOL bCliSide, VARIANT_BOOL bAsync ) {
    HRESULT _hr = raw_ProcessMessageFinish(replyMsg, bCliSide, bAsync);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IContributeDynamicSink wrapper method implementations
//

inline IDynamicMessageSinkPtr IContributeDynamicSink::GetDynamicSink ( ) {
    struct IDynamicMessageSink * _result = 0;
    HRESULT _hr = raw_GetDynamicSink(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDynamicMessageSinkPtr(_result, false);
}

//
// interface IEnvoyInfo wrapper method implementations
//

inline IMessageSinkPtr IEnvoyInfo::GetEnvoySinks ( ) {
    struct IMessageSink * _result = 0;
    HRESULT _hr = get_EnvoySinks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageSinkPtr(_result, false);
}

inline void IEnvoyInfo::PutRefEnvoySinks ( struct IMessageSink * pRetVal ) {
    HRESULT _hr = putref_EnvoySinks(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IContributeEnvoySink wrapper method implementations
//

inline IMessageSinkPtr IContributeEnvoySink::GetEnvoySink ( struct _MarshalByRefObject * obj, struct IMessageSink * NextSink ) {
    struct IMessageSink * _result = 0;
    HRESULT _hr = raw_GetEnvoySink(obj, NextSink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageSinkPtr(_result, false);
}

//
// interface IContributeObjectSink wrapper method implementations
//

inline IMessageSinkPtr IContributeObjectSink::GetObjectSink ( struct _MarshalByRefObject * obj, struct IMessageSink * NextSink ) {
    struct IMessageSink * _result = 0;
    HRESULT _hr = raw_GetObjectSink(obj, NextSink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageSinkPtr(_result, false);
}

//
// interface IAsyncResult wrapper method implementations
//

inline VARIANT_BOOL IAsyncResult::GetIsCompleted ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsCompleted(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _WaitHandlePtr IAsyncResult::GetAsyncWaitHandle ( ) {
    struct _WaitHandle * _result = 0;
    HRESULT _hr = get_AsyncWaitHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _WaitHandlePtr(_result, false);
}

inline _variant_t IAsyncResult::GetAsyncState ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_AsyncState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline VARIANT_BOOL IAsyncResult::GetCompletedSynchronously ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CompletedSynchronously(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISerializable wrapper method implementations
//

inline HRESULT ISerializable::GetObjectData ( struct _SerializationInfo * info, struct StreamingContext Context ) {
    HRESULT _hr = raw_GetObjectData(info, Context);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IEvidenceFactory wrapper method implementations
//

inline _EvidencePtr IEvidenceFactory::GetEvidence ( ) {
    struct _Evidence * _result = 0;
    HRESULT _hr = get_Evidence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _EvidencePtr(_result, false);
}

//
// interface IMembershipCondition wrapper method implementations
//

inline VARIANT_BOOL IMembershipCondition::Check ( struct _Evidence * Evidence ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Check(Evidence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline IMembershipConditionPtr IMembershipCondition::Copy ( ) {
    struct IMembershipCondition * _result = 0;
    HRESULT _hr = raw_Copy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMembershipConditionPtr(_result, false);
}

inline _bstr_t IMembershipCondition::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL IMembershipCondition::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IIdentityPermissionFactory wrapper method implementations
//

inline IPermissionPtr IIdentityPermissionFactory::CreateIdentityPermission ( struct _Evidence * Evidence ) {
    struct IPermission * _result = 0;
    HRESULT _hr = raw_CreateIdentityPermission(Evidence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPermissionPtr(_result, false);
}

//
// interface IApplicationTrustManager wrapper method implementations
//

inline _ApplicationTrustPtr IApplicationTrustManager::DetermineApplicationTrust ( IUnknown * activationContext, struct _TrustManagerContext * Context ) {
    struct _ApplicationTrust * _result = 0;
    HRESULT _hr = raw_DetermineApplicationTrust(activationContext, Context, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ApplicationTrustPtr(_result, false);
}

//
// interface IServerResponseChannelSinkStack wrapper method implementations
//

inline HRESULT IServerResponseChannelSinkStack::AsyncProcessResponse ( struct IMessage * msg, struct ITransportHeaders * headers, struct _Stream * Stream ) {
    HRESULT _hr = raw_AsyncProcessResponse(msg, headers, Stream);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _StreamPtr IServerResponseChannelSinkStack::GetResponseStream ( struct IMessage * msg, struct ITransportHeaders * headers ) {
    struct _Stream * _result = 0;
    HRESULT _hr = raw_GetResponseStream(msg, headers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _StreamPtr(_result, false);
}

//
// interface ISecurityEncodable wrapper method implementations
//

inline _SecurityElementPtr ISecurityEncodable::ToXml ( ) {
    struct _SecurityElement * _result = 0;
    HRESULT _hr = raw_ToXml(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _SecurityElementPtr(_result, false);
}

inline HRESULT ISecurityEncodable::FromXml ( struct _SecurityElement * e ) {
    HRESULT _hr = raw_FromXml(e);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ISecurityPolicyEncodable wrapper method implementations
//

inline _SecurityElementPtr ISecurityPolicyEncodable::ToXml ( struct _PolicyLevel * level ) {
    struct _SecurityElement * _result = 0;
    HRESULT _hr = raw_ToXml(level, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _SecurityElementPtr(_result, false);
}

inline HRESULT ISecurityPolicyEncodable::FromXml ( struct _SecurityElement * e, struct _PolicyLevel * level ) {
    HRESULT _hr = raw_FromXml(e, level);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IContextProperty wrapper method implementations
//

inline _bstr_t IContextProperty::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL IContextProperty::IsNewContextOK ( struct _Context * newCtx ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsNewContextOK(newCtx, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IContextProperty::Freeze ( struct _Context * newContext ) {
    HRESULT _hr = raw_Freeze(newContext);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ITrackingHandler wrapper method implementations
//

inline HRESULT ITrackingHandler::MarshaledObject ( const _variant_t & obj, struct _ObjRef * __or ) {
    HRESULT _hr = raw_MarshaledObject(obj, __or);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ITrackingHandler::UnmarshaledObject ( const _variant_t & obj, struct _ObjRef * __or ) {
    HRESULT _hr = raw_UnmarshaledObject(obj, __or);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ITrackingHandler::DisconnectedObject ( const _variant_t & obj ) {
    HRESULT _hr = raw_DisconnectedObject(obj);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IRemotingFormatter wrapper method implementations
//

inline _variant_t IRemotingFormatter::Deserialize ( struct _Stream * serializationStream, struct _HeaderHandler * handler ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Deserialize(serializationStream, handler, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline HRESULT IRemotingFormatter::Serialize ( struct _Stream * serializationStream, const _variant_t & graph, SAFEARRAY * headers ) {
    HRESULT _hr = raw_Serialize(serializationStream, graph, headers);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ICspAsymmetricAlgorithm wrapper method implementations
//

inline _CspKeyContainerInfoPtr ICspAsymmetricAlgorithm::GetCspKeyContainerInfo ( ) {
    struct _CspKeyContainerInfo * _result = 0;
    HRESULT _hr = get_CspKeyContainerInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _CspKeyContainerInfoPtr(_result, false);
}

inline SAFEARRAY * ICspAsymmetricAlgorithm::ExportCspBlob ( VARIANT_BOOL includePrivateParameters ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ExportCspBlob(includePrivateParameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT ICspAsymmetricAlgorithm::ImportCspBlob ( SAFEARRAY * rawData ) {
    HRESULT _hr = raw_ImportCspBlob(rawData);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _Exception wrapper method implementations
//

inline _bstr_t _Exception::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _Exception::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _Exception::GetHashCode ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _Exception::GetType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _bstr_t _Exception::GetMessage ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Message(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _ExceptionPtr _Exception::GetBaseException ( ) {
    struct _Exception * _result = 0;
    HRESULT _hr = raw_GetBaseException(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ExceptionPtr(_result, false);
}

inline _bstr_t _Exception::GetStackTrace ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StackTrace(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t _Exception::GetHelpLink ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_HelpLink(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _Exception::PutHelpLink ( _bstr_t pRetVal ) {
    HRESULT _hr = put_HelpLink(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t _Exception::GetSource ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Source(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _Exception::PutSource ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Source(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT _Exception::GetObjectData ( struct _SerializationInfo * info, struct StreamingContext Context ) {
    HRESULT _hr = raw_GetObjectData(info, Context);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _ExceptionPtr _Exception::GetInnerException ( ) {
    struct _Exception * _result = 0;
    HRESULT _hr = get_InnerException(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ExceptionPtr(_result, false);
}

inline _MethodBasePtr _Exception::GetTargetSite ( ) {
    struct _MethodBase * _result = 0;
    HRESULT _hr = get_TargetSite(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodBasePtr(_result, false);
}

//
// interface IClientResponseChannelSinkStack wrapper method implementations
//

inline HRESULT IClientResponseChannelSinkStack::AsyncProcessResponse ( struct ITransportHeaders * headers, struct _Stream * Stream ) {
    HRESULT _hr = raw_AsyncProcessResponse(headers, Stream);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IClientResponseChannelSinkStack::DispatchReplyMessage ( struct IMessage * msg ) {
    HRESULT _hr = raw_DispatchReplyMessage(msg);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IClientResponseChannelSinkStack::DispatchException ( struct _Exception * e ) {
    HRESULT _hr = raw_DispatchException(e);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IMethodReturnMessage wrapper method implementations
//

inline long IMethodReturnMessage::GetOutArgCount ( ) {
    long _result = 0;
    HRESULT _hr = get_OutArgCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IMethodReturnMessage::GetOutArgName ( long index ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetOutArgName(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _variant_t IMethodReturnMessage::GetOutArg ( long argNum ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetOutArg(argNum, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline SAFEARRAY * IMethodReturnMessage::GetOutArgs ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_OutArgs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _ExceptionPtr IMethodReturnMessage::GetException ( ) {
    struct _Exception * _result = 0;
    HRESULT _hr = get_Exception(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ExceptionPtr(_result, false);
}

inline _variant_t IMethodReturnMessage::GetReturnValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_ReturnValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IFormattable wrapper method implementations
//

inline _bstr_t IFormattable::GetToString ( _bstr_t format, struct IFormatProvider * formatProvider ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(format, formatProvider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IConvertible wrapper method implementations
//

inline enum TypeCode IConvertible::GetTypeCode ( ) {
    enum TypeCode _result;
    HRESULT _hr = raw_GetTypeCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL IConvertible::ToBoolean ( struct IFormatProvider * provider ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ToBoolean(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned short IConvertible::ToChar ( struct IFormatProvider * provider ) {
    unsigned short _result = 0;
    HRESULT _hr = raw_ToChar(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline char IConvertible::ToSByte ( struct IFormatProvider * provider ) {
    char _result = 0;
    HRESULT _hr = raw_ToSByte(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned char IConvertible::ToByte ( struct IFormatProvider * provider ) {
    unsigned char _result = 0;
    HRESULT _hr = raw_ToByte(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline short IConvertible::ToInt16 ( struct IFormatProvider * provider ) {
    short _result = 0;
    HRESULT _hr = raw_ToInt16(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned short IConvertible::ToUInt16 ( struct IFormatProvider * provider ) {
    unsigned short _result = 0;
    HRESULT _hr = raw_ToUInt16(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long IConvertible::ToInt32 ( struct IFormatProvider * provider ) {
    long _result = 0;
    HRESULT _hr = raw_ToInt32(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IConvertible::ToUInt32 ( struct IFormatProvider * provider ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_ToUInt32(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline __int64 IConvertible::ToInt64 ( struct IFormatProvider * provider ) {
    __int64 _result = 0;
    HRESULT _hr = raw_ToInt64(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned __int64 IConvertible::ToUInt64 ( struct IFormatProvider * provider ) {
    unsigned __int64 _result = 0;
    HRESULT _hr = raw_ToUInt64(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float IConvertible::ToSingle ( struct IFormatProvider * provider ) {
    float _result = 0;
    HRESULT _hr = raw_ToSingle(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline double IConvertible::ToDouble ( struct IFormatProvider * provider ) {
    double _result = 0;
    HRESULT _hr = raw_ToDouble(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline DECIMAL IConvertible::ToDecimal ( struct IFormatProvider * provider ) {
    DECIMAL _result;
    HRESULT _hr = raw_ToDecimal(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline DATE IConvertible::ToDateTime ( struct IFormatProvider * provider ) {
    DATE _result = 0;
    HRESULT _hr = raw_ToDateTime(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IConvertible::GetToString ( struct IFormatProvider * provider ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _variant_t IConvertible::ToType ( struct _Type * conversionType, struct IFormatProvider * provider ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_ToType(conversionType, provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface _AppDomain wrapper method implementations
//

inline HRESULT _AppDomain::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t _AppDomain::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _AppDomain::Equals ( const _variant_t & other ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(other, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _AppDomain::GetHashCode ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _AppDomain::GetType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _variant_t _AppDomain::InitializeLifetimeService ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_InitializeLifetimeService(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t _AppDomain::GetLifetimeService ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetLifetimeService(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _EvidencePtr _AppDomain::GetEvidence ( ) {
    struct _Evidence * _result = 0;
    HRESULT _hr = get_Evidence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _EvidencePtr(_result, false);
}

inline HRESULT _AppDomain::add_DomainUnload ( struct _EventHandler * value ) {
    HRESULT _hr = raw_add_DomainUnload(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::remove_DomainUnload ( struct _EventHandler * value ) {
    HRESULT _hr = raw_remove_DomainUnload(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::add_AssemblyLoad ( struct _AssemblyLoadEventHandler * value ) {
    HRESULT _hr = raw_add_AssemblyLoad(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::remove_AssemblyLoad ( struct _AssemblyLoadEventHandler * value ) {
    HRESULT _hr = raw_remove_AssemblyLoad(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::add_ProcessExit ( struct _EventHandler * value ) {
    HRESULT _hr = raw_add_ProcessExit(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::remove_ProcessExit ( struct _EventHandler * value ) {
    HRESULT _hr = raw_remove_ProcessExit(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::add_TypeResolve ( struct _ResolveEventHandler * value ) {
    HRESULT _hr = raw_add_TypeResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::remove_TypeResolve ( struct _ResolveEventHandler * value ) {
    HRESULT _hr = raw_remove_TypeResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::add_ResourceResolve ( struct _ResolveEventHandler * value ) {
    HRESULT _hr = raw_add_ResourceResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::remove_ResourceResolve ( struct _ResolveEventHandler * value ) {
    HRESULT _hr = raw_remove_ResourceResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::add_AssemblyResolve ( struct _ResolveEventHandler * value ) {
    HRESULT _hr = raw_add_AssemblyResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::remove_AssemblyResolve ( struct _ResolveEventHandler * value ) {
    HRESULT _hr = raw_remove_AssemblyResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::add_UnhandledException ( struct _UnhandledExceptionEventHandler * value ) {
    HRESULT _hr = raw_add_UnhandledException(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::remove_UnhandledException ( struct _UnhandledExceptionEventHandler * value ) {
    HRESULT _hr = raw_remove_UnhandledException(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly ( struct _AssemblyName * name, enum AssemblyBuilderAccess access ) {
    struct _AssemblyBuilder * _result = 0;
    HRESULT _hr = raw_DefineDynamicAssembly(name, access, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_2 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, _bstr_t dir ) {
    struct _AssemblyBuilder * _result = 0;
    HRESULT _hr = raw_DefineDynamicAssembly_2(name, access, dir, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_3 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, struct _Evidence * Evidence ) {
    struct _AssemblyBuilder * _result = 0;
    HRESULT _hr = raw_DefineDynamicAssembly_3(name, access, Evidence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_4 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, struct _PermissionSet * requiredPermissions, struct _PermissionSet * optionalPermissions, struct _PermissionSet * refusedPermissions ) {
    struct _AssemblyBuilder * _result = 0;
    HRESULT _hr = raw_DefineDynamicAssembly_4(name, access, requiredPermissions, optionalPermissions, refusedPermissions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_5 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, _bstr_t dir, struct _Evidence * Evidence ) {
    struct _AssemblyBuilder * _result = 0;
    HRESULT _hr = raw_DefineDynamicAssembly_5(name, access, dir, Evidence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_6 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, _bstr_t dir, struct _PermissionSet * requiredPermissions, struct _PermissionSet * optionalPermissions, struct _PermissionSet * refusedPermissions ) {
    struct _AssemblyBuilder * _result = 0;
    HRESULT _hr = raw_DefineDynamicAssembly_6(name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_7 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, struct _Evidence * Evidence, struct _PermissionSet * requiredPermissions, struct _PermissionSet * optionalPermissions, struct _PermissionSet * refusedPermissions ) {
    struct _AssemblyBuilder * _result = 0;
    HRESULT _hr = raw_DefineDynamicAssembly_7(name, access, Evidence, requiredPermissions, optionalPermissions, refusedPermissions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_8 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, _bstr_t dir, struct _Evidence * Evidence, struct _PermissionSet * requiredPermissions, struct _PermissionSet * optionalPermissions, struct _PermissionSet * refusedPermissions ) {
    struct _AssemblyBuilder * _result = 0;
    HRESULT _hr = raw_DefineDynamicAssembly_8(name, access, dir, Evidence, requiredPermissions, optionalPermissions, refusedPermissions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_9 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, _bstr_t dir, struct _Evidence * Evidence, struct _PermissionSet * requiredPermissions, struct _PermissionSet * optionalPermissions, struct _PermissionSet * refusedPermissions, VARIANT_BOOL IsSynchronized ) {
    struct _AssemblyBuilder * _result = 0;
    HRESULT _hr = raw_DefineDynamicAssembly_9(name, access, dir, Evidence, requiredPermissions, optionalPermissions, refusedPermissions, IsSynchronized, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

inline _ObjectHandlePtr _AppDomain::CreateInstance ( _bstr_t AssemblyName, _bstr_t typeName ) {
    struct _ObjectHandle * _result = 0;
    HRESULT _hr = raw_CreateInstance(AssemblyName, typeName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ObjectHandlePtr(_result, false);
}

inline _ObjectHandlePtr _AppDomain::CreateInstanceFrom ( _bstr_t assemblyFile, _bstr_t typeName ) {
    struct _ObjectHandle * _result = 0;
    HRESULT _hr = raw_CreateInstanceFrom(assemblyFile, typeName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ObjectHandlePtr(_result, false);
}

inline _ObjectHandlePtr _AppDomain::CreateInstance_2 ( _bstr_t AssemblyName, _bstr_t typeName, SAFEARRAY * activationAttributes ) {
    struct _ObjectHandle * _result = 0;
    HRESULT _hr = raw_CreateInstance_2(AssemblyName, typeName, activationAttributes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ObjectHandlePtr(_result, false);
}

inline _ObjectHandlePtr _AppDomain::CreateInstanceFrom_2 ( _bstr_t assemblyFile, _bstr_t typeName, SAFEARRAY * activationAttributes ) {
    struct _ObjectHandle * _result = 0;
    HRESULT _hr = raw_CreateInstanceFrom_2(assemblyFile, typeName, activationAttributes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ObjectHandlePtr(_result, false);
}

inline _ObjectHandlePtr _AppDomain::CreateInstance_3 ( _bstr_t AssemblyName, _bstr_t typeName, VARIANT_BOOL ignoreCase, enum BindingFlags bindingAttr, struct _Binder * Binder, SAFEARRAY * args, struct _CultureInfo * culture, SAFEARRAY * activationAttributes, struct _Evidence * securityAttributes ) {
    struct _ObjectHandle * _result = 0;
    HRESULT _hr = raw_CreateInstance_3(AssemblyName, typeName, ignoreCase, bindingAttr, Binder, args, culture, activationAttributes, securityAttributes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ObjectHandlePtr(_result, false);
}

inline _ObjectHandlePtr _AppDomain::CreateInstanceFrom_3 ( _bstr_t assemblyFile, _bstr_t typeName, VARIANT_BOOL ignoreCase, enum BindingFlags bindingAttr, struct _Binder * Binder, SAFEARRAY * args, struct _CultureInfo * culture, SAFEARRAY * activationAttributes, struct _Evidence * securityAttributes ) {
    struct _ObjectHandle * _result = 0;
    HRESULT _hr = raw_CreateInstanceFrom_3(assemblyFile, typeName, ignoreCase, bindingAttr, Binder, args, culture, activationAttributes, securityAttributes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ObjectHandlePtr(_result, false);
}

inline _AssemblyPtr _AppDomain::Load ( struct _AssemblyName * assemblyRef ) {
    struct _Assembly * _result = 0;
    HRESULT _hr = raw_Load(assemblyRef, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

inline _AssemblyPtr _AppDomain::Load_2 ( _bstr_t assemblyString ) {
    struct _Assembly * _result = 0;
    HRESULT _hr = raw_Load_2(assemblyString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

inline _AssemblyPtr _AppDomain::Load_3 ( SAFEARRAY * rawAssembly ) {
    struct _Assembly * _result = 0;
    HRESULT _hr = raw_Load_3(rawAssembly, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

inline _AssemblyPtr _AppDomain::Load_4 ( SAFEARRAY * rawAssembly, SAFEARRAY * rawSymbolStore ) {
    struct _Assembly * _result = 0;
    HRESULT _hr = raw_Load_4(rawAssembly, rawSymbolStore, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

inline _AssemblyPtr _AppDomain::Load_5 ( SAFEARRAY * rawAssembly, SAFEARRAY * rawSymbolStore, struct _Evidence * securityEvidence ) {
    struct _Assembly * _result = 0;
    HRESULT _hr = raw_Load_5(rawAssembly, rawSymbolStore, securityEvidence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

inline _AssemblyPtr _AppDomain::Load_6 ( struct _AssemblyName * assemblyRef, struct _Evidence * assemblySecurity ) {
    struct _Assembly * _result = 0;
    HRESULT _hr = raw_Load_6(assemblyRef, assemblySecurity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

inline _AssemblyPtr _AppDomain::Load_7 ( _bstr_t assemblyString, struct _Evidence * assemblySecurity ) {
    struct _Assembly * _result = 0;
    HRESULT _hr = raw_Load_7(assemblyString, assemblySecurity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

inline long _AppDomain::ExecuteAssembly ( _bstr_t assemblyFile, struct _Evidence * assemblySecurity ) {
    long _result = 0;
    HRESULT _hr = raw_ExecuteAssembly(assemblyFile, assemblySecurity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _AppDomain::ExecuteAssembly_2 ( _bstr_t assemblyFile ) {
    long _result = 0;
    HRESULT _hr = raw_ExecuteAssembly_2(assemblyFile, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _AppDomain::ExecuteAssembly_3 ( _bstr_t assemblyFile, struct _Evidence * assemblySecurity, SAFEARRAY * args ) {
    long _result = 0;
    HRESULT _hr = raw_ExecuteAssembly_3(assemblyFile, assemblySecurity, args, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t _AppDomain::GetFriendlyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FriendlyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t _AppDomain::GetBaseDirectory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_BaseDirectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t _AppDomain::GetRelativeSearchPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_RelativeSearchPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _AppDomain::GetShadowCopyFiles ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShadowCopyFiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _AppDomain::GetAssemblies ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetAssemblies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT _AppDomain::AppendPrivatePath ( _bstr_t Path ) {
    HRESULT _hr = raw_AppendPrivatePath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::ClearPrivatePath ( ) {
    HRESULT _hr = raw_ClearPrivatePath();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::SetShadowCopyPath ( _bstr_t s ) {
    HRESULT _hr = raw_SetShadowCopyPath(s);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::ClearShadowCopyPath ( ) {
    HRESULT _hr = raw_ClearShadowCopyPath();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::SetCachePath ( _bstr_t s ) {
    HRESULT _hr = raw_SetCachePath(s);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::SetData ( _bstr_t name, const _variant_t & data ) {
    HRESULT _hr = raw_SetData(name, data);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _variant_t _AppDomain::GetData ( _bstr_t name ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetData(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline HRESULT _AppDomain::SetAppDomainPolicy ( struct _PolicyLevel * domainPolicy ) {
    HRESULT _hr = raw_SetAppDomainPolicy(domainPolicy);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::SetThreadPrincipal ( struct IPrincipal * principal ) {
    HRESULT _hr = raw_SetThreadPrincipal(principal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::SetPrincipalPolicy ( enum PrincipalPolicy policy ) {
    HRESULT _hr = raw_SetPrincipalPolicy(policy);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _AppDomain::DoCallBack ( struct _CrossAppDomainDelegate * theDelegate ) {
    HRESULT _hr = raw_DoCallBack(theDelegate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t _AppDomain::GetDynamicDirectory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DynamicDirectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface ICustomFormatter wrapper method implementations
//

inline _bstr_t ICustomFormatter::format ( _bstr_t format, const _variant_t & arg, struct IFormatProvider * formatProvider ) {
    BSTR _result = 0;
    HRESULT _hr = raw_format(format, arg, formatProvider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IFormatProvider wrapper method implementations
//

inline _variant_t IFormatProvider::GetFormat ( struct _Type * formatType ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetFormat(formatType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface ICustomAttributeProvider wrapper method implementations
//

inline SAFEARRAY * ICustomAttributeProvider::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * ICustomAttributeProvider::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL ICustomAttributeProvider::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _MemberInfo wrapper method implementations
//

inline HRESULT _MemberInfo::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _MemberInfo::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _MemberInfo::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _MemberInfo::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t _MemberInfo::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _MemberInfo::Equals ( const _variant_t & other ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(other, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _MemberInfo::GetHashCode ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _MemberInfo::GetType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline enum MemberTypes _MemberInfo::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t _MemberInfo::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _TypePtr _MemberInfo::GetDeclaringType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _TypePtr _MemberInfo::GetReflectedType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline SAFEARRAY * _MemberInfo::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _MemberInfo::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MemberInfo::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _Type wrapper method implementations
//

inline HRESULT _Type::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Type::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Type::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Type::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t _Type::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _Type::Equals ( const _variant_t & other ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(other, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _Type::GetHashCode ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _Type::GetType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline enum MemberTypes _Type::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t _Type::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _TypePtr _Type::GetDeclaringType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _TypePtr _Type::GetReflectedType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline SAFEARRAY * _Type::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Type::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline GUID _Type::GetGuid ( ) {
    GUID _result;
    HRESULT _hr = get_Guid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _ModulePtr _Type::GetModule ( ) {
    struct _Module * _result = 0;
    HRESULT _hr = get_Module(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ModulePtr(_result, false);
}

inline _AssemblyPtr _Type::GetAssembly ( ) {
    struct _Assembly * _result = 0;
    HRESULT _hr = get_Assembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

inline struct RuntimeTypeHandle _Type::GetTypeHandle ( ) {
    struct RuntimeTypeHandle _result;
    HRESULT _hr = get_TypeHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t _Type::GetFullName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FullName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t _Type::GetNamespace ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Namespace(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t _Type::GetAssemblyQualifiedName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_AssemblyQualifiedName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline long _Type::GetArrayRank ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetArrayRank(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _Type::GetBaseType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_BaseType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline SAFEARRAY * _Type::GetConstructors ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetConstructors(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _Type::GetInterface ( _bstr_t name, VARIANT_BOOL ignoreCase ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetInterface(name, ignoreCase, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline SAFEARRAY * _Type::GetInterfaces ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetInterfaces(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Type::FindInterfaces ( struct _TypeFilter * filter, const _variant_t & filterCriteria ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_FindInterfaces(filter, filterCriteria, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _EventInfoPtr _Type::GetEvent ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _EventInfo * _result = 0;
    HRESULT _hr = raw_GetEvent(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _EventInfoPtr(_result, false);
}

inline SAFEARRAY * _Type::GetEvents ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetEvents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Type::GetEvents_2 ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetEvents_2(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Type::GetNestedTypes ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetNestedTypes(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _Type::GetNestedType ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetNestedType(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline SAFEARRAY * _Type::GetMember ( _bstr_t name, enum MemberTypes Type, enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetMember(name, Type, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Type::GetDefaultMembers ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetDefaultMembers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Type::FindMembers ( enum MemberTypes MemberType, enum BindingFlags bindingAttr, struct _MemberFilter * filter, const _variant_t & filterCriteria ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_FindMembers(MemberType, bindingAttr, filter, filterCriteria, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _Type::GetElementType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline VARIANT_BOOL _Type::IsSubclassOf ( struct _Type * c ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsSubclassOf(c, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::IsInstanceOfType ( const _variant_t & o ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsInstanceOfType(o, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::IsAssignableFrom ( struct _Type * c ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsAssignableFrom(c, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline struct InterfaceMapping _Type::GetInterfaceMap ( struct _Type * interfaceType ) {
    struct InterfaceMapping _result;
    HRESULT _hr = raw_GetInterfaceMap(interfaceType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _MethodInfoPtr _Type::GetMethod ( _bstr_t name, enum BindingFlags bindingAttr, struct _Binder * Binder, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetMethod(name, bindingAttr, Binder, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline _MethodInfoPtr _Type::GetMethod_2 ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetMethod_2(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline SAFEARRAY * _Type::GetMethods ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetMethods(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _FieldInfoPtr _Type::GetField ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _FieldInfo * _result = 0;
    HRESULT _hr = raw_GetField(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FieldInfoPtr(_result, false);
}

inline SAFEARRAY * _Type::GetFields ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetFields(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _PropertyInfoPtr _Type::GetProperty ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _PropertyInfo * _result = 0;
    HRESULT _hr = raw_GetProperty(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

inline _PropertyInfoPtr _Type::GetProperty_2 ( _bstr_t name, enum BindingFlags bindingAttr, struct _Binder * Binder, struct _Type * returnType, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _PropertyInfo * _result = 0;
    HRESULT _hr = raw_GetProperty_2(name, bindingAttr, Binder, returnType, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

inline SAFEARRAY * _Type::GetProperties ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetProperties(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Type::GetMember_2 ( _bstr_t name, enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetMember_2(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Type::GetMembers ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetMembers(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t _Type::InvokeMember ( _bstr_t name, enum BindingFlags invokeAttr, struct _Binder * Binder, const _variant_t & Target, SAFEARRAY * args, SAFEARRAY * modifiers, struct _CultureInfo * culture, SAFEARRAY * namedParameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_InvokeMember(name, invokeAttr, Binder, Target, args, modifiers, culture, namedParameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _TypePtr _Type::GetUnderlyingSystemType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_UnderlyingSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _variant_t _Type::InvokeMember_2 ( _bstr_t name, enum BindingFlags invokeAttr, struct _Binder * Binder, const _variant_t & Target, SAFEARRAY * args, struct _CultureInfo * culture ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_InvokeMember_2(name, invokeAttr, Binder, Target, args, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t _Type::InvokeMember_3 ( _bstr_t name, enum BindingFlags invokeAttr, struct _Binder * Binder, const _variant_t & Target, SAFEARRAY * args ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_InvokeMember_3(name, invokeAttr, Binder, Target, args, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _ConstructorInfoPtr _Type::GetConstructor ( enum BindingFlags bindingAttr, struct _Binder * Binder, enum CallingConventions callConvention, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _ConstructorInfo * _result = 0;
    HRESULT _hr = raw_GetConstructor(bindingAttr, Binder, callConvention, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ConstructorInfoPtr(_result, false);
}

inline _ConstructorInfoPtr _Type::GetConstructor_2 ( enum BindingFlags bindingAttr, struct _Binder * Binder, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _ConstructorInfo * _result = 0;
    HRESULT _hr = raw_GetConstructor_2(bindingAttr, Binder, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ConstructorInfoPtr(_result, false);
}

inline _ConstructorInfoPtr _Type::GetConstructor_3 ( SAFEARRAY * types ) {
    struct _ConstructorInfo * _result = 0;
    HRESULT _hr = raw_GetConstructor_3(types, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ConstructorInfoPtr(_result, false);
}

inline SAFEARRAY * _Type::GetConstructors_2 ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetConstructors_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _ConstructorInfoPtr _Type::GetTypeInitializer ( ) {
    struct _ConstructorInfo * _result = 0;
    HRESULT _hr = get_TypeInitializer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ConstructorInfoPtr(_result, false);
}

inline _MethodInfoPtr _Type::GetMethod_3 ( _bstr_t name, enum BindingFlags bindingAttr, struct _Binder * Binder, enum CallingConventions callConvention, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetMethod_3(name, bindingAttr, Binder, callConvention, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline _MethodInfoPtr _Type::GetMethod_4 ( _bstr_t name, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetMethod_4(name, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline _MethodInfoPtr _Type::GetMethod_5 ( _bstr_t name, SAFEARRAY * types ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetMethod_5(name, types, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline _MethodInfoPtr _Type::GetMethod_6 ( _bstr_t name ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetMethod_6(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline SAFEARRAY * _Type::GetMethods_2 ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetMethods_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _FieldInfoPtr _Type::GetField_2 ( _bstr_t name ) {
    struct _FieldInfo * _result = 0;
    HRESULT _hr = raw_GetField_2(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FieldInfoPtr(_result, false);
}

inline SAFEARRAY * _Type::GetFields_2 ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetFields_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _Type::GetInterface_2 ( _bstr_t name ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetInterface_2(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _EventInfoPtr _Type::GetEvent_2 ( _bstr_t name ) {
    struct _EventInfo * _result = 0;
    HRESULT _hr = raw_GetEvent_2(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _EventInfoPtr(_result, false);
}

inline _PropertyInfoPtr _Type::GetProperty_3 ( _bstr_t name, struct _Type * returnType, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _PropertyInfo * _result = 0;
    HRESULT _hr = raw_GetProperty_3(name, returnType, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

inline _PropertyInfoPtr _Type::GetProperty_4 ( _bstr_t name, struct _Type * returnType, SAFEARRAY * types ) {
    struct _PropertyInfo * _result = 0;
    HRESULT _hr = raw_GetProperty_4(name, returnType, types, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

inline _PropertyInfoPtr _Type::GetProperty_5 ( _bstr_t name, SAFEARRAY * types ) {
    struct _PropertyInfo * _result = 0;
    HRESULT _hr = raw_GetProperty_5(name, types, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

inline _PropertyInfoPtr _Type::GetProperty_6 ( _bstr_t name, struct _Type * returnType ) {
    struct _PropertyInfo * _result = 0;
    HRESULT _hr = raw_GetProperty_6(name, returnType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

inline _PropertyInfoPtr _Type::GetProperty_7 ( _bstr_t name ) {
    struct _PropertyInfo * _result = 0;
    HRESULT _hr = raw_GetProperty_7(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

inline SAFEARRAY * _Type::GetProperties_2 ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetProperties_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Type::GetNestedTypes_2 ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetNestedTypes_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _Type::GetNestedType_2 ( _bstr_t name ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetNestedType_2(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline SAFEARRAY * _Type::GetMember_3 ( _bstr_t name ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetMember_3(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Type::GetMembers_2 ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetMembers_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum TypeAttributes _Type::GetAttributes ( ) {
    enum TypeAttributes _result;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsNotPublic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNotPublic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsPublic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPublic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsNestedPublic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNestedPublic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsNestedPrivate ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNestedPrivate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsNestedFamily ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNestedFamily(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsNestedAssembly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNestedAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsNestedFamANDAssem ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNestedFamANDAssem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsNestedFamORAssem ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNestedFamORAssem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsAutoLayout ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsAutoLayout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsLayoutSequential ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsLayoutSequential(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsExplicitLayout ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsExplicitLayout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsClass ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsClass(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsInterface ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsInterface(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsValueType ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValueType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsAbstract ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsAbstract(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsSealed ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSealed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsEnum ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsSpecialName ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSpecialName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsImport ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsImport(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsSerializable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSerializable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsAnsiClass ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsAnsiClass(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsUnicodeClass ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsUnicodeClass(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsAutoClass ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsAutoClass(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsArray ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsByRef ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsByRef(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsPointer ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPointer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsPrimitive ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPrimitive(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsCOMObject ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsCOMObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetHasElementType ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsContextful ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsContextful(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::GetIsMarshalByRef ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsMarshalByRef(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Type::Equals_2 ( struct _Type * o ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals_2(o, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IFormatterConverter wrapper method implementations
//

inline _variant_t IFormatterConverter::Convert ( const _variant_t & value, struct _Type * Type ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Convert(value, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t IFormatterConverter::Convert_2 ( const _variant_t & value, enum TypeCode TypeCode ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Convert_2(value, TypeCode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline VARIANT_BOOL IFormatterConverter::ToBoolean ( const _variant_t & value ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ToBoolean(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned short IFormatterConverter::ToChar ( const _variant_t & value ) {
    unsigned short _result = 0;
    HRESULT _hr = raw_ToChar(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline char IFormatterConverter::ToSByte ( const _variant_t & value ) {
    char _result = 0;
    HRESULT _hr = raw_ToSByte(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned char IFormatterConverter::ToByte ( const _variant_t & value ) {
    unsigned char _result = 0;
    HRESULT _hr = raw_ToByte(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline short IFormatterConverter::ToInt16 ( const _variant_t & value ) {
    short _result = 0;
    HRESULT _hr = raw_ToInt16(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned short IFormatterConverter::ToUInt16 ( const _variant_t & value ) {
    unsigned short _result = 0;
    HRESULT _hr = raw_ToUInt16(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long IFormatterConverter::ToInt32 ( const _variant_t & value ) {
    long _result = 0;
    HRESULT _hr = raw_ToInt32(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IFormatterConverter::ToUInt32 ( const _variant_t & value ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_ToUInt32(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline __int64 IFormatterConverter::ToInt64 ( const _variant_t & value ) {
    __int64 _result = 0;
    HRESULT _hr = raw_ToInt64(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned __int64 IFormatterConverter::ToUInt64 ( const _variant_t & value ) {
    unsigned __int64 _result = 0;
    HRESULT _hr = raw_ToUInt64(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float IFormatterConverter::ToSingle ( const _variant_t & value ) {
    float _result = 0;
    HRESULT _hr = raw_ToSingle(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline double IFormatterConverter::ToDouble ( const _variant_t & value ) {
    double _result = 0;
    HRESULT _hr = raw_ToDouble(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline DECIMAL IFormatterConverter::ToDecimal ( const _variant_t & value ) {
    DECIMAL _result;
    HRESULT _hr = raw_ToDecimal(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline DATE IFormatterConverter::ToDateTime ( const _variant_t & value ) {
    DATE _result = 0;
    HRESULT _hr = raw_ToDateTime(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IFormatterConverter::GetToString ( const _variant_t & value ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface ICustomFactory wrapper method implementations
//

inline _MarshalByRefObjectPtr ICustomFactory::CreateInstance ( struct _Type * serverType ) {
    struct _MarshalByRefObject * _result = 0;
    HRESULT _hr = raw_CreateInstance(serverType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MarshalByRefObjectPtr(_result, false);
}

//
// interface IRemotingTypeInfo wrapper method implementations
//

inline _bstr_t IRemotingTypeInfo::GettypeName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_typeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IRemotingTypeInfo::PuttypeName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_typeName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL IRemotingTypeInfo::CanCastTo ( struct _Type * fromType, const _variant_t & o ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CanCastTo(fromType, o, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _Object wrapper method implementations
//

inline _bstr_t _Object::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _Object::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _Object::GetHashCode ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _Object::GetType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

//
// interface _ObjectHandle wrapper method implementations
//

inline _bstr_t _ObjectHandle::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _ObjectHandle::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _ObjectHandle::GetHashCode ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _ObjectHandle::GetType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _variant_t _ObjectHandle::GetLifetimeService ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetLifetimeService(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t _ObjectHandle::InitializeLifetimeService ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_InitializeLifetimeService(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _ObjRefPtr _ObjectHandle::CreateObjRef ( struct _Type * requestedType ) {
    struct _ObjRef * _result = 0;
    HRESULT _hr = raw_CreateObjRef(requestedType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ObjRefPtr(_result, false);
}

inline _variant_t _ObjectHandle::Unwrap ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Unwrap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IReflect wrapper method implementations
//

inline _MethodInfoPtr IReflect::GetMethod ( _bstr_t name, enum BindingFlags bindingAttr, struct _Binder * Binder, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetMethod(name, bindingAttr, Binder, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline _MethodInfoPtr IReflect::GetMethod_2 ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetMethod_2(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline SAFEARRAY * IReflect::GetMethods ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetMethods(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _FieldInfoPtr IReflect::GetField ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _FieldInfo * _result = 0;
    HRESULT _hr = raw_GetField(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FieldInfoPtr(_result, false);
}

inline SAFEARRAY * IReflect::GetFields ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetFields(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _PropertyInfoPtr IReflect::GetProperty ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _PropertyInfo * _result = 0;
    HRESULT _hr = raw_GetProperty(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

inline _PropertyInfoPtr IReflect::GetProperty_2 ( _bstr_t name, enum BindingFlags bindingAttr, struct _Binder * Binder, struct _Type * returnType, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _PropertyInfo * _result = 0;
    HRESULT _hr = raw_GetProperty_2(name, bindingAttr, Binder, returnType, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

inline SAFEARRAY * IReflect::GetProperties ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetProperties(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * IReflect::GetMember ( _bstr_t name, enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetMember(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * IReflect::GetMembers ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetMembers(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t IReflect::InvokeMember ( _bstr_t name, enum BindingFlags invokeAttr, struct _Binder * Binder, const _variant_t & Target, SAFEARRAY * args, SAFEARRAY * modifiers, struct _CultureInfo * culture, SAFEARRAY * namedParameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_InvokeMember(name, invokeAttr, Binder, Target, args, modifiers, culture, namedParameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _TypePtr IReflect::GetUnderlyingSystemType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_UnderlyingSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

//
// interface ISymbolBinder wrapper method implementations
//

inline ISymbolReaderPtr ISymbolBinder::GetReader ( long importer, _bstr_t filename, _bstr_t searchPath ) {
    struct ISymbolReader * _result = 0;
    HRESULT _hr = raw_GetReader(importer, filename, searchPath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolReaderPtr(_result, false);
}

//
// interface ISymbolBinder1 wrapper method implementations
//

inline ISymbolReaderPtr ISymbolBinder1::GetReader ( long importer, _bstr_t filename, _bstr_t searchPath ) {
    struct ISymbolReader * _result = 0;
    HRESULT _hr = raw_GetReader(importer, filename, searchPath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolReaderPtr(_result, false);
}

//
// interface ISymbolMethod wrapper method implementations
//

inline struct SymbolToken ISymbolMethod::GetToken ( ) {
    struct SymbolToken _result;
    HRESULT _hr = get_Token(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ISymbolMethod::GetSequencePointCount ( ) {
    long _result = 0;
    HRESULT _hr = get_SequencePointCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT ISymbolMethod::GetSequencePoints ( SAFEARRAY * offsets, SAFEARRAY * documents, SAFEARRAY * lines, SAFEARRAY * columns, SAFEARRAY * endLines, SAFEARRAY * endColumns ) {
    HRESULT _hr = raw_GetSequencePoints(offsets, documents, lines, columns, endLines, endColumns);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline ISymbolScopePtr ISymbolMethod::GetRootScope ( ) {
    struct ISymbolScope * _result = 0;
    HRESULT _hr = get_RootScope(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolScopePtr(_result, false);
}

inline ISymbolScopePtr ISymbolMethod::GetScope ( long offset ) {
    struct ISymbolScope * _result = 0;
    HRESULT _hr = raw_GetScope(offset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolScopePtr(_result, false);
}

inline long ISymbolMethod::GetOffset ( struct ISymbolDocument * document, long line, long column ) {
    long _result = 0;
    HRESULT _hr = raw_GetOffset(document, line, column, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * ISymbolMethod::GetRanges ( struct ISymbolDocument * document, long line, long column ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetRanges(document, line, column, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * ISymbolMethod::GetParameters ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetParameters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline ISymbolNamespacePtr ISymbolMethod::GetNamespace ( ) {
    struct ISymbolNamespace * _result = 0;
    HRESULT _hr = raw_GetNamespace(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolNamespacePtr(_result, false);
}

inline VARIANT_BOOL ISymbolMethod::GetSourceStartEnd ( SAFEARRAY * docs, SAFEARRAY * lines, SAFEARRAY * columns ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetSourceStartEnd(docs, lines, columns, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISymbolReader wrapper method implementations
//

inline ISymbolDocumentPtr ISymbolReader::GetDocument ( _bstr_t Url, GUID Language, GUID LanguageVendor, GUID DocumentType ) {
    struct ISymbolDocument * _result = 0;
    HRESULT _hr = raw_GetDocument(Url, Language, LanguageVendor, DocumentType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolDocumentPtr(_result, false);
}

inline SAFEARRAY * ISymbolReader::GetDocuments ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetDocuments(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline struct SymbolToken ISymbolReader::GetUserEntryPoint ( ) {
    struct SymbolToken _result;
    HRESULT _hr = get_UserEntryPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline ISymbolMethodPtr ISymbolReader::GetMethod ( struct SymbolToken Method ) {
    struct ISymbolMethod * _result = 0;
    HRESULT _hr = raw_GetMethod(Method, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolMethodPtr(_result, false);
}

inline ISymbolMethodPtr ISymbolReader::GetMethod_2 ( struct SymbolToken Method, long Version ) {
    struct ISymbolMethod * _result = 0;
    HRESULT _hr = raw_GetMethod_2(Method, Version, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolMethodPtr(_result, false);
}

inline SAFEARRAY * ISymbolReader::GetVariables ( struct SymbolToken parent ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetVariables(parent, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * ISymbolReader::GetGlobalVariables ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetGlobalVariables(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline ISymbolMethodPtr ISymbolReader::GetMethodFromDocumentPosition ( struct ISymbolDocument * document, long line, long column ) {
    struct ISymbolMethod * _result = 0;
    HRESULT _hr = raw_GetMethodFromDocumentPosition(document, line, column, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolMethodPtr(_result, false);
}

inline SAFEARRAY * ISymbolReader::GetSymAttribute ( struct SymbolToken parent, _bstr_t name ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetSymAttribute(parent, name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * ISymbolReader::GetNamespaces ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetNamespaces(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISymbolScope wrapper method implementations
//

inline ISymbolMethodPtr ISymbolScope::GetMethod ( ) {
    struct ISymbolMethod * _result = 0;
    HRESULT _hr = get_Method(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolMethodPtr(_result, false);
}

inline ISymbolScopePtr ISymbolScope::Getparent ( ) {
    struct ISymbolScope * _result = 0;
    HRESULT _hr = get_parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolScopePtr(_result, false);
}

inline SAFEARRAY * ISymbolScope::GetChildren ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetChildren(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ISymbolScope::GetStartOffset ( ) {
    long _result = 0;
    HRESULT _hr = get_StartOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long ISymbolScope::GetEndOffset ( ) {
    long _result = 0;
    HRESULT _hr = get_EndOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * ISymbolScope::GetLocals ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetLocals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * ISymbolScope::GetNamespaces ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetNamespaces(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _Assembly wrapper method implementations
//

inline _bstr_t _Assembly::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _Assembly::Equals ( const _variant_t & other ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(other, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _Assembly::GetHashCode ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _Assembly::GetType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _bstr_t _Assembly::GetCodeBase ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CodeBase(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t _Assembly::GetEscapedCodeBase ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_EscapedCodeBase(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _AssemblyNamePtr _Assembly::GetName ( ) {
    struct _AssemblyName * _result = 0;
    HRESULT _hr = raw_GetName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyNamePtr(_result, false);
}

inline _AssemblyNamePtr _Assembly::GetName_2 ( VARIANT_BOOL copiedName ) {
    struct _AssemblyName * _result = 0;
    HRESULT _hr = raw_GetName_2(copiedName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyNamePtr(_result, false);
}

inline _bstr_t _Assembly::GetFullName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FullName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _MethodInfoPtr _Assembly::GetEntryPoint ( ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = get_EntryPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline _TypePtr _Assembly::GetType_2 ( _bstr_t name ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType_2(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _TypePtr _Assembly::GetType_3 ( _bstr_t name, VARIANT_BOOL throwOnError ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType_3(name, throwOnError, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline SAFEARRAY * _Assembly::GetExportedTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetExportedTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Assembly::GetTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _StreamPtr _Assembly::GetManifestResourceStream ( struct _Type * Type, _bstr_t name ) {
    struct _Stream * _result = 0;
    HRESULT _hr = raw_GetManifestResourceStream(Type, name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _StreamPtr(_result, false);
}

inline _StreamPtr _Assembly::GetManifestResourceStream_2 ( _bstr_t name ) {
    struct _Stream * _result = 0;
    HRESULT _hr = raw_GetManifestResourceStream_2(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _StreamPtr(_result, false);
}

inline _FileStreamPtr _Assembly::GetFile ( _bstr_t name ) {
    struct _FileStream * _result = 0;
    HRESULT _hr = raw_GetFile(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FileStreamPtr(_result, false);
}

inline SAFEARRAY * _Assembly::GetFiles ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetFiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Assembly::GetFiles_2 ( VARIANT_BOOL getResourceModules ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetFiles_2(getResourceModules, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Assembly::GetManifestResourceNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetManifestResourceNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _ManifestResourceInfoPtr _Assembly::GetManifestResourceInfo ( _bstr_t resourceName ) {
    struct _ManifestResourceInfo * _result = 0;
    HRESULT _hr = raw_GetManifestResourceInfo(resourceName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ManifestResourceInfoPtr(_result, false);
}

inline _bstr_t _Assembly::GetLocation ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Location(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _EvidencePtr _Assembly::GetEvidence ( ) {
    struct _Evidence * _result = 0;
    HRESULT _hr = get_Evidence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _EvidencePtr(_result, false);
}

inline SAFEARRAY * _Assembly::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Assembly::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Assembly::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT _Assembly::GetObjectData ( struct _SerializationInfo * info, struct StreamingContext Context ) {
    HRESULT _hr = raw_GetObjectData(info, Context);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Assembly::add_ModuleResolve ( struct _ModuleResolveEventHandler * value ) {
    HRESULT _hr = raw_add_ModuleResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _Assembly::remove_ModuleResolve ( struct _ModuleResolveEventHandler * value ) {
    HRESULT _hr = raw_remove_ModuleResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _TypePtr _Assembly::GetType_4 ( _bstr_t name, VARIANT_BOOL throwOnError, VARIANT_BOOL ignoreCase ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType_4(name, throwOnError, ignoreCase, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _AssemblyPtr _Assembly::GetSatelliteAssembly ( struct _CultureInfo * culture ) {
    struct _Assembly * _result = 0;
    HRESULT _hr = raw_GetSatelliteAssembly(culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

inline _AssemblyPtr _Assembly::GetSatelliteAssembly_2 ( struct _CultureInfo * culture, struct _Version * Version ) {
    struct _Assembly * _result = 0;
    HRESULT _hr = raw_GetSatelliteAssembly_2(culture, Version, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

inline _ModulePtr _Assembly::LoadModule ( _bstr_t moduleName, SAFEARRAY * rawModule ) {
    struct _Module * _result = 0;
    HRESULT _hr = raw_LoadModule(moduleName, rawModule, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ModulePtr(_result, false);
}

inline _ModulePtr _Assembly::LoadModule_2 ( _bstr_t moduleName, SAFEARRAY * rawModule, SAFEARRAY * rawSymbolStore ) {
    struct _Module * _result = 0;
    HRESULT _hr = raw_LoadModule_2(moduleName, rawModule, rawSymbolStore, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ModulePtr(_result, false);
}

inline _variant_t _Assembly::CreateInstance ( _bstr_t typeName ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_CreateInstance(typeName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t _Assembly::CreateInstance_2 ( _bstr_t typeName, VARIANT_BOOL ignoreCase ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_CreateInstance_2(typeName, ignoreCase, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t _Assembly::CreateInstance_3 ( _bstr_t typeName, VARIANT_BOOL ignoreCase, enum BindingFlags bindingAttr, struct _Binder * Binder, SAFEARRAY * args, struct _CultureInfo * culture, SAFEARRAY * activationAttributes ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_CreateInstance_3(typeName, ignoreCase, bindingAttr, Binder, args, culture, activationAttributes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline SAFEARRAY * _Assembly::GetLoadedModules ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetLoadedModules(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Assembly::GetLoadedModules_2 ( VARIANT_BOOL getResourceModules ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetLoadedModules_2(getResourceModules, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Assembly::GetModules ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetModules(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _Assembly::GetModules_2 ( VARIANT_BOOL getResourceModules ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetModules_2(getResourceModules, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _ModulePtr _Assembly::GetModule ( _bstr_t name ) {
    struct _Module * _result = 0;
    HRESULT _hr = raw_GetModule(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ModulePtr(_result, false);
}

inline SAFEARRAY * _Assembly::GetReferencedAssemblies ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetReferencedAssemblies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Assembly::GetGlobalAssemblyCache ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_GlobalAssemblyCache(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ITypeLibImporterNotifySink wrapper method implementations
//

inline HRESULT ITypeLibImporterNotifySink::__ReportEvent ( enum ImporterEventKind eventKind, long eventCode, _bstr_t eventMsg ) {
    HRESULT _hr = raw___ReportEvent(eventKind, eventCode, eventMsg);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _AssemblyPtr ITypeLibImporterNotifySink::ResolveRef ( IUnknown * typeLib ) {
    struct _Assembly * _result = 0;
    HRESULT _hr = raw_ResolveRef(typeLib, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

//
// interface IRegistrationServices wrapper method implementations
//

inline VARIANT_BOOL IRegistrationServices::RegisterAssembly ( struct _Assembly * Assembly, enum AssemblyRegistrationFlags flags ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_RegisterAssembly(Assembly, flags, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL IRegistrationServices::UnregisterAssembly ( struct _Assembly * Assembly ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UnregisterAssembly(Assembly, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * IRegistrationServices::GetRegistrableTypesInAssembly ( struct _Assembly * Assembly ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetRegistrableTypesInAssembly(Assembly, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IRegistrationServices::GetProgIdForType ( struct _Type * Type ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetProgIdForType(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline HRESULT IRegistrationServices::RegisterTypeForComClients ( struct _Type * Type, GUID * G ) {
    HRESULT _hr = raw_RegisterTypeForComClients(Type, G);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline GUID IRegistrationServices::GetManagedCategoryGuid ( ) {
    GUID _result;
    HRESULT _hr = raw_GetManagedCategoryGuid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL IRegistrationServices::TypeRequiresRegistration ( struct _Type * Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_TypeRequiresRegistration(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL IRegistrationServices::TypeRepresentsComType ( struct _Type * Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_TypeRepresentsComType(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ITypeLibExporterNotifySink wrapper method implementations
//

inline HRESULT ITypeLibExporterNotifySink::__ReportEvent ( enum ExporterEventKind eventKind, long eventCode, _bstr_t eventMsg ) {
    HRESULT _hr = raw___ReportEvent(eventKind, eventCode, eventMsg);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline IUnknownPtr ITypeLibExporterNotifySink::ResolveRef ( struct _Assembly * Assembly ) {
    IUnknown * _result = 0;
    HRESULT _hr = raw_ResolveRef(Assembly, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface ITypeLibConverter wrapper method implementations
//

inline _AssemblyBuilderPtr ITypeLibConverter::ConvertTypeLibToAssembly ( IUnknown * typeLib, _bstr_t asmFileName, enum TypeLibImporterFlags flags, struct ITypeLibImporterNotifySink * notifySink, SAFEARRAY * publicKey, struct _StrongNameKeyPair * keyPair, _bstr_t asmNamespace, struct _Version * asmVersion ) {
    struct _AssemblyBuilder * _result = 0;
    HRESULT _hr = raw_ConvertTypeLibToAssembly(typeLib, asmFileName, flags, notifySink, publicKey, keyPair, asmNamespace, asmVersion, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

inline IUnknownPtr ITypeLibConverter::ConvertAssemblyToTypeLib ( struct _Assembly * Assembly, _bstr_t typeLibName, enum TypeLibExporterFlags flags, struct ITypeLibExporterNotifySink * notifySink ) {
    IUnknown * _result = 0;
    HRESULT _hr = raw_ConvertAssemblyToTypeLib(Assembly, typeLibName, flags, notifySink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

inline VARIANT_BOOL ITypeLibConverter::GetPrimaryInteropAssembly ( GUID G, long major, long minor, long lcid, BSTR * asmName, BSTR * asmCodeBase ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetPrimaryInteropAssembly(G, major, minor, lcid, asmName, asmCodeBase, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _AssemblyBuilderPtr ITypeLibConverter::ConvertTypeLibToAssembly_2 ( IUnknown * typeLib, _bstr_t asmFileName, long flags, struct ITypeLibImporterNotifySink * notifySink, SAFEARRAY * publicKey, struct _StrongNameKeyPair * keyPair, VARIANT_BOOL unsafeInterfaces ) {
    struct _AssemblyBuilder * _result = 0;
    HRESULT _hr = raw_ConvertTypeLibToAssembly_2(typeLib, asmFileName, flags, notifySink, publicKey, keyPair, unsafeInterfaces, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

//
// interface _MethodBase wrapper method implementations
//

inline HRESULT _MethodBase::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _MethodBase::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _MethodBase::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _MethodBase::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t _MethodBase::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _MethodBase::Equals ( const _variant_t & other ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(other, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _MethodBase::GetHashCode ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _MethodBase::GetType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline enum MemberTypes _MethodBase::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t _MethodBase::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _TypePtr _MethodBase::GetDeclaringType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _TypePtr _MethodBase::GetReflectedType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline SAFEARRAY * _MethodBase::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _MethodBase::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodBase::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _MethodBase::GetParameters ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetParameters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum MethodImplAttributes _MethodBase::GetMethodImplementationFlags ( ) {
    enum MethodImplAttributes _result;
    HRESULT _hr = raw_GetMethodImplementationFlags(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline struct RuntimeMethodHandle _MethodBase::GetMethodHandle ( ) {
    struct RuntimeMethodHandle _result;
    HRESULT _hr = get_MethodHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum MethodAttributes _MethodBase::GetAttributes ( ) {
    enum MethodAttributes _result;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum CallingConventions _MethodBase::GetCallingConvention ( ) {
    enum CallingConventions _result;
    HRESULT _hr = get_CallingConvention(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t _MethodBase::Invoke_2 ( const _variant_t & obj, enum BindingFlags invokeAttr, struct _Binder * Binder, SAFEARRAY * parameters, struct _CultureInfo * culture ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_2(obj, invokeAttr, Binder, parameters, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline VARIANT_BOOL _MethodBase::GetIsPublic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPublic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodBase::GetIsPrivate ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPrivate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodBase::GetIsFamily ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFamily(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodBase::GetIsAssembly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodBase::GetIsFamilyAndAssembly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFamilyAndAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodBase::GetIsFamilyOrAssembly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFamilyOrAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodBase::GetIsStatic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsStatic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodBase::GetIsFinal ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFinal(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodBase::GetIsVirtual ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsVirtual(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodBase::GetIsHideBySig ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsHideBySig(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodBase::GetIsAbstract ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsAbstract(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodBase::GetIsSpecialName ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSpecialName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodBase::GetIsConstructor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsConstructor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t _MethodBase::Invoke_3 ( const _variant_t & obj, SAFEARRAY * parameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_3(obj, parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IMethodMessage wrapper method implementations
//

inline _bstr_t IMethodMessage::GetUri ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Uri(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IMethodMessage::GetMethodName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_MethodName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IMethodMessage::GettypeName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_typeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _variant_t IMethodMessage::GetMethodSignature ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_MethodSignature(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline long IMethodMessage::GetArgCount ( ) {
    long _result = 0;
    HRESULT _hr = get_ArgCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IMethodMessage::GetArgName ( long index ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetArgName(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _variant_t IMethodMessage::GetArg ( long argNum ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetArg(argNum, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline SAFEARRAY * IMethodMessage::Getargs ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_args(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL IMethodMessage::GetHasVarArgs ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasVarArgs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _LogicalCallContextPtr IMethodMessage::GetLogicalCallContext ( ) {
    struct _LogicalCallContext * _result = 0;
    HRESULT _hr = get_LogicalCallContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _LogicalCallContextPtr(_result, false);
}

inline _MethodBasePtr IMethodMessage::GetMethodBase ( ) {
    struct _MethodBase * _result = 0;
    HRESULT _hr = get_MethodBase(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodBasePtr(_result, false);
}

//
// interface _MethodInfo wrapper method implementations
//

inline HRESULT _MethodInfo::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _MethodInfo::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _MethodInfo::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _MethodInfo::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t _MethodInfo::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _MethodInfo::Equals ( const _variant_t & other ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(other, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _MethodInfo::GetHashCode ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _MethodInfo::GetType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline enum MemberTypes _MethodInfo::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t _MethodInfo::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _TypePtr _MethodInfo::GetDeclaringType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _TypePtr _MethodInfo::GetReflectedType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline SAFEARRAY * _MethodInfo::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _MethodInfo::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodInfo::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _MethodInfo::GetParameters ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetParameters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum MethodImplAttributes _MethodInfo::GetMethodImplementationFlags ( ) {
    enum MethodImplAttributes _result;
    HRESULT _hr = raw_GetMethodImplementationFlags(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline struct RuntimeMethodHandle _MethodInfo::GetMethodHandle ( ) {
    struct RuntimeMethodHandle _result;
    HRESULT _hr = get_MethodHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum MethodAttributes _MethodInfo::GetAttributes ( ) {
    enum MethodAttributes _result;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum CallingConventions _MethodInfo::GetCallingConvention ( ) {
    enum CallingConventions _result;
    HRESULT _hr = get_CallingConvention(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t _MethodInfo::Invoke_2 ( const _variant_t & obj, enum BindingFlags invokeAttr, struct _Binder * Binder, SAFEARRAY * parameters, struct _CultureInfo * culture ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_2(obj, invokeAttr, Binder, parameters, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline VARIANT_BOOL _MethodInfo::GetIsPublic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPublic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodInfo::GetIsPrivate ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPrivate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodInfo::GetIsFamily ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFamily(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodInfo::GetIsAssembly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodInfo::GetIsFamilyAndAssembly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFamilyAndAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodInfo::GetIsFamilyOrAssembly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFamilyOrAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodInfo::GetIsStatic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsStatic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodInfo::GetIsFinal ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFinal(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodInfo::GetIsVirtual ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsVirtual(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodInfo::GetIsHideBySig ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsHideBySig(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodInfo::GetIsAbstract ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsAbstract(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodInfo::GetIsSpecialName ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSpecialName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _MethodInfo::GetIsConstructor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsConstructor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t _MethodInfo::Invoke_3 ( const _variant_t & obj, SAFEARRAY * parameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_3(obj, parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _TypePtr _MethodInfo::GetreturnType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_returnType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline ICustomAttributeProviderPtr _MethodInfo::GetReturnTypeCustomAttributes ( ) {
    struct ICustomAttributeProvider * _result = 0;
    HRESULT _hr = get_ReturnTypeCustomAttributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICustomAttributeProviderPtr(_result, false);
}

inline _MethodInfoPtr _MethodInfo::GetBaseDefinition ( ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetBaseDefinition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

//
// interface _Delegate wrapper method implementations
//

inline _bstr_t _Delegate::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _Delegate::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _Delegate::GetHashCode ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _Delegate::GetType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline SAFEARRAY * _Delegate::GetInvocationList ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetInvocationList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t _Delegate::Clone ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Clone(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline HRESULT _Delegate::GetObjectData ( struct _SerializationInfo * info, struct StreamingContext Context ) {
    HRESULT _hr = raw_GetObjectData(info, Context);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _variant_t _Delegate::DynamicInvoke ( SAFEARRAY * args ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_DynamicInvoke(args, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _MethodInfoPtr _Delegate::GetMethod ( ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = get_Method(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline _variant_t _Delegate::GetTarget ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Target(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface _EventInfo wrapper method implementations
//

inline HRESULT _EventInfo::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _EventInfo::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _EventInfo::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _EventInfo::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t _EventInfo::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _EventInfo::Equals ( const _variant_t & other ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(other, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _EventInfo::GetHashCode ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _EventInfo::GetType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline enum MemberTypes _EventInfo::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t _EventInfo::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _TypePtr _EventInfo::GetDeclaringType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _TypePtr _EventInfo::GetReflectedType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline SAFEARRAY * _EventInfo::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _EventInfo::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _EventInfo::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _MethodInfoPtr _EventInfo::GetAddMethod ( VARIANT_BOOL nonPublic ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetAddMethod(nonPublic, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline _MethodInfoPtr _EventInfo::GetRemoveMethod ( VARIANT_BOOL nonPublic ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetRemoveMethod(nonPublic, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline _MethodInfoPtr _EventInfo::GetRaiseMethod ( VARIANT_BOOL nonPublic ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetRaiseMethod(nonPublic, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline enum EventAttributes _EventInfo::GetAttributes ( ) {
    enum EventAttributes _result;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _MethodInfoPtr _EventInfo::GetAddMethod_2 ( ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetAddMethod_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline _MethodInfoPtr _EventInfo::GetRemoveMethod_2 ( ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetRemoveMethod_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline _MethodInfoPtr _EventInfo::GetRaiseMethod_2 ( ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetRaiseMethod_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline HRESULT _EventInfo::AddEventHandler ( const _variant_t & Target, struct _Delegate * handler ) {
    HRESULT _hr = raw_AddEventHandler(Target, handler);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _EventInfo::RemoveEventHandler ( const _variant_t & Target, struct _Delegate * handler ) {
    HRESULT _hr = raw_RemoveEventHandler(Target, handler);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _TypePtr _EventInfo::GetEventHandlerType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_EventHandlerType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline VARIANT_BOOL _EventInfo::GetIsSpecialName ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSpecialName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _EventInfo::GetIsMulticast ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsMulticast(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _ConstructorInfo wrapper method implementations
//

inline HRESULT _ConstructorInfo::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ConstructorInfo::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ConstructorInfo::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _ConstructorInfo::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t _ConstructorInfo::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _ConstructorInfo::Equals ( const _variant_t & other ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(other, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _ConstructorInfo::GetHashCode ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _ConstructorInfo::GetType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline enum MemberTypes _ConstructorInfo::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t _ConstructorInfo::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _TypePtr _ConstructorInfo::GetDeclaringType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _TypePtr _ConstructorInfo::GetReflectedType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline SAFEARRAY * _ConstructorInfo::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _ConstructorInfo::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _ConstructorInfo::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _ConstructorInfo::GetParameters ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetParameters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum MethodImplAttributes _ConstructorInfo::GetMethodImplementationFlags ( ) {
    enum MethodImplAttributes _result;
    HRESULT _hr = raw_GetMethodImplementationFlags(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline struct RuntimeMethodHandle _ConstructorInfo::GetMethodHandle ( ) {
    struct RuntimeMethodHandle _result;
    HRESULT _hr = get_MethodHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum MethodAttributes _ConstructorInfo::GetAttributes ( ) {
    enum MethodAttributes _result;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum CallingConventions _ConstructorInfo::GetCallingConvention ( ) {
    enum CallingConventions _result;
    HRESULT _hr = get_CallingConvention(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t _ConstructorInfo::Invoke_2 ( const _variant_t & obj, enum BindingFlags invokeAttr, struct _Binder * Binder, SAFEARRAY * parameters, struct _CultureInfo * culture ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_2(obj, invokeAttr, Binder, parameters, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline VARIANT_BOOL _ConstructorInfo::GetIsPublic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPublic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _ConstructorInfo::GetIsPrivate ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPrivate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _ConstructorInfo::GetIsFamily ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFamily(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _ConstructorInfo::GetIsAssembly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _ConstructorInfo::GetIsFamilyAndAssembly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFamilyAndAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _ConstructorInfo::GetIsFamilyOrAssembly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFamilyOrAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _ConstructorInfo::GetIsStatic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsStatic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _ConstructorInfo::GetIsFinal ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFinal(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _ConstructorInfo::GetIsVirtual ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsVirtual(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _ConstructorInfo::GetIsHideBySig ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsHideBySig(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _ConstructorInfo::GetIsAbstract ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsAbstract(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _ConstructorInfo::GetIsSpecialName ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSpecialName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _ConstructorInfo::GetIsConstructor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsConstructor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t _ConstructorInfo::Invoke_3 ( const _variant_t & obj, SAFEARRAY * parameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_3(obj, parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t _ConstructorInfo::Invoke_4 ( enum BindingFlags invokeAttr, struct _Binder * Binder, SAFEARRAY * parameters, struct _CultureInfo * culture ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_4(invokeAttr, Binder, parameters, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t _ConstructorInfo::Invoke_5 ( SAFEARRAY * parameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_5(parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface _FieldInfo wrapper method implementations
//

inline HRESULT _FieldInfo::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _FieldInfo::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _FieldInfo::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _FieldInfo::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t _FieldInfo::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _FieldInfo::Equals ( const _variant_t & other ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(other, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _FieldInfo::GetHashCode ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _FieldInfo::GetType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline enum MemberTypes _FieldInfo::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t _FieldInfo::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _TypePtr _FieldInfo::GetDeclaringType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _TypePtr _FieldInfo::GetReflectedType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline SAFEARRAY * _FieldInfo::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _FieldInfo::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _FieldInfo::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _FieldInfo::GetFieldType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_FieldType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _variant_t _FieldInfo::GetValue ( const _variant_t & obj ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetValue(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t _FieldInfo::GetValueDirect ( const _variant_t & obj ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetValueDirect(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline HRESULT _FieldInfo::SetValue ( const _variant_t & obj, const _variant_t & value, enum BindingFlags invokeAttr, struct _Binder * Binder, struct _CultureInfo * culture ) {
    HRESULT _hr = raw_SetValue(obj, value, invokeAttr, Binder, culture);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _FieldInfo::SetValueDirect ( const _variant_t & obj, const _variant_t & value ) {
    HRESULT _hr = raw_SetValueDirect(obj, value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline struct RuntimeFieldHandle _FieldInfo::GetFieldHandle ( ) {
    struct RuntimeFieldHandle _result;
    HRESULT _hr = get_FieldHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum FieldAttributes _FieldInfo::GetAttributes ( ) {
    enum FieldAttributes _result;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT _FieldInfo::SetValue_2 ( const _variant_t & obj, const _variant_t & value ) {
    HRESULT _hr = raw_SetValue_2(obj, value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline VARIANT_BOOL _FieldInfo::GetIsPublic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPublic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _FieldInfo::GetIsPrivate ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPrivate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _FieldInfo::GetIsFamily ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFamily(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _FieldInfo::GetIsAssembly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _FieldInfo::GetIsFamilyAndAssembly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFamilyAndAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _FieldInfo::GetIsFamilyOrAssembly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFamilyOrAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _FieldInfo::GetIsStatic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsStatic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _FieldInfo::GetIsInitOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsInitOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _FieldInfo::GetIsLiteral ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsLiteral(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _FieldInfo::GetIsNotSerialized ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNotSerialized(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _FieldInfo::GetIsSpecialName ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSpecialName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _FieldInfo::GetIsPinvokeImpl ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPinvokeImpl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _PropertyInfo wrapper method implementations
//

inline HRESULT _PropertyInfo::GetTypeInfoCount ( unsigned long * pcTInfo ) {
    HRESULT _hr = raw_GetTypeInfoCount(pcTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _PropertyInfo::GetTypeInfo ( unsigned long iTInfo, unsigned long lcid, long ppTInfo ) {
    HRESULT _hr = raw_GetTypeInfo(iTInfo, lcid, ppTInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _PropertyInfo::GetIDsOfNames ( GUID * riid, long rgszNames, unsigned long cNames, unsigned long lcid, long rgDispId ) {
    HRESULT _hr = raw_GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _PropertyInfo::Invoke ( unsigned long dispIdMember, GUID * riid, unsigned long lcid, short wFlags, long pDispParams, long pVarResult, long pExcepInfo, long puArgErr ) {
    HRESULT _hr = raw_Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t _PropertyInfo::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _PropertyInfo::Equals ( const _variant_t & other ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(other, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _PropertyInfo::GetHashCode ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _PropertyInfo::GetType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline enum MemberTypes _PropertyInfo::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t _PropertyInfo::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _TypePtr _PropertyInfo::GetDeclaringType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _TypePtr _PropertyInfo::GetReflectedType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline SAFEARRAY * _PropertyInfo::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _PropertyInfo::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _PropertyInfo::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _PropertyInfo::GetPropertyType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_PropertyType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _variant_t _PropertyInfo::GetValue ( const _variant_t & obj, SAFEARRAY * index ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetValue(obj, index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t _PropertyInfo::GetValue_2 ( const _variant_t & obj, enum BindingFlags invokeAttr, struct _Binder * Binder, SAFEARRAY * index, struct _CultureInfo * culture ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetValue_2(obj, invokeAttr, Binder, index, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline HRESULT _PropertyInfo::SetValue ( const _variant_t & obj, const _variant_t & value, SAFEARRAY * index ) {
    HRESULT _hr = raw_SetValue(obj, value, index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _PropertyInfo::SetValue_2 ( const _variant_t & obj, const _variant_t & value, enum BindingFlags invokeAttr, struct _Binder * Binder, SAFEARRAY * index, struct _CultureInfo * culture ) {
    HRESULT _hr = raw_SetValue_2(obj, value, invokeAttr, Binder, index, culture);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline SAFEARRAY * _PropertyInfo::GetAccessors ( VARIANT_BOOL nonPublic ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetAccessors(nonPublic, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _MethodInfoPtr _PropertyInfo::GetGetMethod ( VARIANT_BOOL nonPublic ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetGetMethod(nonPublic, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline _MethodInfoPtr _PropertyInfo::GetSetMethod ( VARIANT_BOOL nonPublic ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetSetMethod(nonPublic, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline SAFEARRAY * _PropertyInfo::GetIndexParameters ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetIndexParameters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum PropertyAttributes _PropertyInfo::GetAttributes ( ) {
    enum PropertyAttributes _result;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _PropertyInfo::GetCanRead ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanRead(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _PropertyInfo::GetCanWrite ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanWrite(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * _PropertyInfo::GetAccessors_2 ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetAccessors_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _MethodInfoPtr _PropertyInfo::GetGetMethod_2 ( ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetGetMethod_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline _MethodInfoPtr _PropertyInfo::GetSetMethod_2 ( ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_GetSetMethod_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline VARIANT_BOOL _PropertyInfo::GetIsSpecialName ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSpecialName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IExpando wrapper method implementations
//

inline _FieldInfoPtr IExpando::AddField ( _bstr_t name ) {
    struct _FieldInfo * _result = 0;
    HRESULT _hr = raw_AddField(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FieldInfoPtr(_result, false);
}

inline _PropertyInfoPtr IExpando::AddProperty ( _bstr_t name ) {
    struct _PropertyInfo * _result = 0;
    HRESULT _hr = raw_AddProperty(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

inline _MethodInfoPtr IExpando::AddMethod ( _bstr_t name, struct _Delegate * Method ) {
    struct _MethodInfo * _result = 0;
    HRESULT _hr = raw_AddMethod(name, Method, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

inline HRESULT IExpando::RemoveMember ( struct _MemberInfo * m ) {
    HRESULT _hr = raw_RemoveMember(m);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _Binder wrapper method implementations
//

inline _bstr_t _Binder::GetToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL _Binder::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _Binder::GetHashCode ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _TypePtr _Binder::GetType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline _MethodBasePtr _Binder::BindToMethod ( enum BindingFlags bindingAttr, SAFEARRAY * match, SAFEARRAY * * args, SAFEARRAY * modifiers, struct _CultureInfo * culture, SAFEARRAY * names, VARIANT * state ) {
    struct _MethodBase * _result = 0;
    HRESULT _hr = raw_BindToMethod(bindingAttr, match, args, modifiers, culture, names, state, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodBasePtr(_result, false);
}

inline _FieldInfoPtr _Binder::BindToField ( enum BindingFlags bindingAttr, SAFEARRAY * match, const _variant_t & value, struct _CultureInfo * culture ) {
    struct _FieldInfo * _result = 0;
    HRESULT _hr = raw_BindToField(bindingAttr, match, value, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FieldInfoPtr(_result, false);
}

inline _MethodBasePtr _Binder::SelectMethod ( enum BindingFlags bindingAttr, SAFEARRAY * match, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _MethodBase * _result = 0;
    HRESULT _hr = raw_SelectMethod(bindingAttr, match, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodBasePtr(_result, false);
}

inline _PropertyInfoPtr _Binder::SelectProperty ( enum BindingFlags bindingAttr, SAFEARRAY * match, struct _Type * returnType, SAFEARRAY * indexes, SAFEARRAY * modifiers ) {
    struct _PropertyInfo * _result = 0;
    HRESULT _hr = raw_SelectProperty(bindingAttr, match, returnType, indexes, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

inline _variant_t _Binder::ChangeType ( const _variant_t & value, struct _Type * Type, struct _CultureInfo * culture ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_ChangeType(value, Type, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline HRESULT _Binder::ReorderArgumentArray ( SAFEARRAY * * args, const _variant_t & state ) {
    HRESULT _hr = raw_ReorderArgumentArray(args, state);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ISerializationSurrogate wrapper method implementations
//

inline HRESULT ISerializationSurrogate::GetObjectData ( const _variant_t & obj, struct _SerializationInfo * info, struct StreamingContext Context ) {
    HRESULT _hr = raw_GetObjectData(obj, info, Context);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _variant_t ISerializationSurrogate::SetObjectData ( const _variant_t & obj, struct _SerializationInfo * info, struct StreamingContext Context, struct ISurrogateSelector * selector ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_SetObjectData(obj, info, Context, selector, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface ISurrogateSelector wrapper method implementations
//

inline HRESULT ISurrogateSelector::ChainSelector ( struct ISurrogateSelector * selector ) {
    HRESULT _hr = raw_ChainSelector(selector);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline ISerializationSurrogatePtr ISurrogateSelector::GetSurrogate ( struct _Type * Type, struct StreamingContext Context, struct ISurrogateSelector * * selector ) {
    struct ISerializationSurrogate * _result = 0;
    HRESULT _hr = raw_GetSurrogate(Type, Context, selector, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISerializationSurrogatePtr(_result, false);
}

inline ISurrogateSelectorPtr ISurrogateSelector::GetNextSelector ( ) {
    struct ISurrogateSelector * _result = 0;
    HRESULT _hr = raw_GetNextSelector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISurrogateSelectorPtr(_result, false);
}

//
// interface IFormatter wrapper method implementations
//

inline _variant_t IFormatter::Deserialize ( struct _Stream * serializationStream ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Deserialize(serializationStream, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline HRESULT IFormatter::Serialize ( struct _Stream * serializationStream, const _variant_t & graph ) {
    HRESULT _hr = raw_Serialize(serializationStream, graph);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline ISurrogateSelectorPtr IFormatter::GetSurrogateSelector ( ) {
    struct ISurrogateSelector * _result = 0;
    HRESULT _hr = get_SurrogateSelector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISurrogateSelectorPtr(_result, false);
}

inline void IFormatter::PutRefSurrogateSelector ( struct ISurrogateSelector * pRetVal ) {
    HRESULT _hr = putref_SurrogateSelector(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _SerializationBinderPtr IFormatter::GetBinder ( ) {
    struct _SerializationBinder * _result = 0;
    HRESULT _hr = get_Binder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _SerializationBinderPtr(_result, false);
}

inline void IFormatter::PutRefBinder ( struct _SerializationBinder * pRetVal ) {
    HRESULT _hr = putref_Binder(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline struct StreamingContext IFormatter::GetContext ( ) {
    struct StreamingContext _result;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IFormatter::PutContext ( struct StreamingContext pRetVal ) {
    HRESULT _hr = put_Context(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IContextAttribute wrapper method implementations
//

inline VARIANT_BOOL IContextAttribute::IsContextOK ( struct _Context * ctx, struct IConstructionCallMessage * msg ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsContextOK(ctx, msg, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IContextAttribute::GetPropertiesForNewContext ( struct IConstructionCallMessage * msg ) {
    HRESULT _hr = raw_GetPropertiesForNewContext(msg);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IActivator wrapper method implementations
//

inline IActivatorPtr IActivator::GetNextActivator ( ) {
    struct IActivator * _result = 0;
    HRESULT _hr = get_NextActivator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IActivatorPtr(_result, false);
}

inline void IActivator::PutRefNextActivator ( struct IActivator * pRetVal ) {
    HRESULT _hr = putref_NextActivator(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline IConstructionReturnMessagePtr IActivator::Activate ( struct IConstructionCallMessage * msg ) {
    struct IConstructionReturnMessage * _result = 0;
    HRESULT _hr = raw_Activate(msg, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IConstructionReturnMessagePtr(_result, false);
}

inline enum ActivatorLevel IActivator::Getlevel ( ) {
    enum ActivatorLevel _result;
    HRESULT _hr = get_level(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IConstructionCallMessage wrapper method implementations
//

inline IActivatorPtr IConstructionCallMessage::GetActivator ( ) {
    struct IActivator * _result = 0;
    HRESULT _hr = get_Activator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IActivatorPtr(_result, false);
}

inline void IConstructionCallMessage::PutRefActivator ( struct IActivator * pRetVal ) {
    HRESULT _hr = putref_Activator(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline SAFEARRAY * IConstructionCallMessage::GetCallSiteActivationAttributes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_CallSiteActivationAttributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IConstructionCallMessage::GetActivationTypeName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ActivationTypeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _TypePtr IConstructionCallMessage::GetActivationType ( ) {
    struct _Type * _result = 0;
    HRESULT _hr = get_ActivationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

inline IListPtr IConstructionCallMessage::GetContextProperties ( ) {
    struct IList * _result = 0;
    HRESULT _hr = get_ContextProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IListPtr(_result, false);
}

//
// interface IContextPropertyActivator wrapper method implementations
//

inline VARIANT_BOOL IContextPropertyActivator::IsOKToActivate ( struct IConstructionCallMessage * msg ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsOKToActivate(msg, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IContextPropertyActivator::CollectFromClientContext ( struct IConstructionCallMessage * msg ) {
    HRESULT _hr = raw_CollectFromClientContext(msg);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline VARIANT_BOOL IContextPropertyActivator::DeliverClientContextToServerContext ( struct IConstructionCallMessage * msg ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DeliverClientContextToServerContext(msg, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IContextPropertyActivator::CollectFromServerContext ( struct IConstructionReturnMessage * msg ) {
    HRESULT _hr = raw_CollectFromServerContext(msg);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline VARIANT_BOOL IContextPropertyActivator::DeliverServerContextToClientContext ( struct IConstructionReturnMessage * msg ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DeliverServerContextToClientContext(msg, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IClientChannelSinkStack wrapper method implementations
//

inline HRESULT IClientChannelSinkStack::Push ( struct IClientChannelSink * sink, const _variant_t & state ) {
    HRESULT _hr = raw_Push(sink, state);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _variant_t IClientChannelSinkStack::Pop ( struct IClientChannelSink * sink ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Pop(sink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IClientChannelSink wrapper method implementations
//

inline HRESULT IClientChannelSink::ProcessMessage ( struct IMessage * msg, struct ITransportHeaders * requestHeaders, struct _Stream * requestStream, struct ITransportHeaders * * responseHeaders, struct _Stream * * responseStream ) {
    HRESULT _hr = raw_ProcessMessage(msg, requestHeaders, requestStream, responseHeaders, responseStream);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IClientChannelSink::AsyncProcessRequest ( struct IClientChannelSinkStack * sinkStack, struct IMessage * msg, struct ITransportHeaders * headers, struct _Stream * Stream ) {
    HRESULT _hr = raw_AsyncProcessRequest(sinkStack, msg, headers, Stream);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IClientChannelSink::AsyncProcessResponse ( struct IClientResponseChannelSinkStack * sinkStack, const _variant_t & state, struct ITransportHeaders * headers, struct _Stream * Stream ) {
    HRESULT _hr = raw_AsyncProcessResponse(sinkStack, state, headers, Stream);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _StreamPtr IClientChannelSink::GetRequestStream ( struct IMessage * msg, struct ITransportHeaders * headers ) {
    struct _Stream * _result = 0;
    HRESULT _hr = raw_GetRequestStream(msg, headers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _StreamPtr(_result, false);
}

inline IClientChannelSinkPtr IClientChannelSink::GetNextChannelSink ( ) {
    struct IClientChannelSink * _result = 0;
    HRESULT _hr = get_NextChannelSink(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IClientChannelSinkPtr(_result, false);
}

//
// interface IClientChannelSinkProvider wrapper method implementations
//

inline IClientChannelSinkPtr IClientChannelSinkProvider::CreateSink ( struct IChannelSender * channel, _bstr_t Url, const _variant_t & remoteChannelData ) {
    struct IClientChannelSink * _result = 0;
    HRESULT _hr = raw_CreateSink(channel, Url, remoteChannelData, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IClientChannelSinkPtr(_result, false);
}

inline IClientChannelSinkProviderPtr IClientChannelSinkProvider::GetNext ( ) {
    struct IClientChannelSinkProvider * _result = 0;
    HRESULT _hr = get_Next(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IClientChannelSinkProviderPtr(_result, false);
}

inline void IClientChannelSinkProvider::PutRefNext ( struct IClientChannelSinkProvider * pRetVal ) {
    HRESULT _hr = putref_Next(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IServerChannelSinkStack wrapper method implementations
//

inline HRESULT IServerChannelSinkStack::Push ( struct IServerChannelSink * sink, const _variant_t & state ) {
    HRESULT _hr = raw_Push(sink, state);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _variant_t IServerChannelSinkStack::Pop ( struct IServerChannelSink * sink ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Pop(sink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline HRESULT IServerChannelSinkStack::Store ( struct IServerChannelSink * sink, const _variant_t & state ) {
    HRESULT _hr = raw_Store(sink, state);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IServerChannelSinkStack::StoreAndDispatch ( struct IServerChannelSink * sink, const _variant_t & state ) {
    HRESULT _hr = raw_StoreAndDispatch(sink, state);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IServerChannelSinkStack::ServerCallback ( struct IAsyncResult * ar ) {
    HRESULT _hr = raw_ServerCallback(ar);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IServerChannelSink wrapper method implementations
//

inline enum ServerProcessing IServerChannelSink::ProcessMessage ( struct IServerChannelSinkStack * sinkStack, struct IMessage * requestMsg, struct ITransportHeaders * requestHeaders, struct _Stream * requestStream, struct IMessage * * responseMsg, struct ITransportHeaders * * responseHeaders, struct _Stream * * responseStream ) {
    enum ServerProcessing _result;
    HRESULT _hr = raw_ProcessMessage(sinkStack, requestMsg, requestHeaders, requestStream, responseMsg, responseHeaders, responseStream, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IServerChannelSink::AsyncProcessResponse ( struct IServerResponseChannelSinkStack * sinkStack, const _variant_t & state, struct IMessage * msg, struct ITransportHeaders * headers, struct _Stream * Stream ) {
    HRESULT _hr = raw_AsyncProcessResponse(sinkStack, state, msg, headers, Stream);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _StreamPtr IServerChannelSink::GetResponseStream ( struct IServerResponseChannelSinkStack * sinkStack, const _variant_t & state, struct IMessage * msg, struct ITransportHeaders * headers ) {
    struct _Stream * _result = 0;
    HRESULT _hr = raw_GetResponseStream(sinkStack, state, msg, headers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _StreamPtr(_result, false);
}

inline IServerChannelSinkPtr IServerChannelSink::GetNextChannelSink ( ) {
    struct IServerChannelSink * _result = 0;
    HRESULT _hr = get_NextChannelSink(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IServerChannelSinkPtr(_result, false);
}

//
// interface IServerChannelSinkProvider wrapper method implementations
//

inline HRESULT IServerChannelSinkProvider::GetChannelData ( struct IChannelDataStore * ChannelData ) {
    HRESULT _hr = raw_GetChannelData(ChannelData);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline IServerChannelSinkPtr IServerChannelSinkProvider::CreateSink ( struct IChannelReceiver * channel ) {
    struct IServerChannelSink * _result = 0;
    HRESULT _hr = raw_CreateSink(channel, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IServerChannelSinkPtr(_result, false);
}

inline IServerChannelSinkProviderPtr IServerChannelSinkProvider::GetNext ( ) {
    struct IServerChannelSinkProvider * _result = 0;
    HRESULT _hr = get_Next(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IServerChannelSinkProviderPtr(_result, false);
}

inline void IServerChannelSinkProvider::PutRefNext ( struct IServerChannelSinkProvider * pRetVal ) {
    HRESULT _hr = putref_Next(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IChannelReceiverHook wrapper method implementations
//

inline _bstr_t IChannelReceiverHook::GetChannelScheme ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ChannelScheme(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL IChannelReceiverHook::GetWantsToListen ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_WantsToListen(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline IServerChannelSinkPtr IChannelReceiverHook::GetChannelSinkChain ( ) {
    struct IServerChannelSink * _result = 0;
    HRESULT _hr = get_ChannelSinkChain(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IServerChannelSinkPtr(_result, false);
}

inline HRESULT IChannelReceiverHook::AddHookChannelUri ( _bstr_t channelUri ) {
    HRESULT _hr = raw_AddHookChannelUri(channelUri);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ISponsor wrapper method implementations
//

inline struct TimeSpan ISponsor::Renewal ( struct ILease * lease ) {
    struct TimeSpan _result;
    HRESULT _hr = raw_Renewal(lease, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ILease wrapper method implementations
//

inline HRESULT ILease::Register ( struct ISponsor * obj, struct TimeSpan renewalTime ) {
    HRESULT _hr = raw_Register(obj, renewalTime);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ILease::Register_2 ( struct ISponsor * obj ) {
    HRESULT _hr = raw_Register_2(obj);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ILease::Unregister ( struct ISponsor * obj ) {
    HRESULT _hr = raw_Unregister(obj);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline struct TimeSpan ILease::Renew ( struct TimeSpan renewalTime ) {
    struct TimeSpan _result;
    HRESULT _hr = raw_Renew(renewalTime, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline struct TimeSpan ILease::GetRenewOnCallTime ( ) {
    struct TimeSpan _result;
    HRESULT _hr = get_RenewOnCallTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ILease::PutRenewOnCallTime ( struct TimeSpan pRetVal ) {
    HRESULT _hr = put_RenewOnCallTime(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline struct TimeSpan ILease::GetSponsorshipTimeout ( ) {
    struct TimeSpan _result;
    HRESULT _hr = get_SponsorshipTimeout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ILease::PutSponsorshipTimeout ( struct TimeSpan pRetVal ) {
    HRESULT _hr = put_SponsorshipTimeout(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline struct TimeSpan ILease::GetInitialLeaseTime ( ) {
    struct TimeSpan _result;
    HRESULT _hr = get_InitialLeaseTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void ILease::PutInitialLeaseTime ( struct TimeSpan pRetVal ) {
    HRESULT _hr = put_InitialLeaseTime(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline struct TimeSpan ILease::GetCurrentLeaseTime ( ) {
    struct TimeSpan _result;
    HRESULT _hr = get_CurrentLeaseTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline enum LeaseState ILease::GetCurrentState ( ) {
    enum LeaseState _result;
    HRESULT _hr = get_CurrentState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}
